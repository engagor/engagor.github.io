<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[CX Social Dev Blog]]></title>
    <link href="/blog/tags/API.xml" rel="self"/>
    <link href="/"/>
    <updated>2017-10-16T07:43:10+00:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Real-Time Webhooks API: Secure an Internship with us]]></title>
            <link href="/blog/2017/09/27/internship-webhooks-api"/>
            <updated>2017-09-27T11:00:00+00:00</updated>
            <id>/blog/2017/09/27/internship-webhooks-api</id>
            <content type="html"><![CDATA[<p>Are you a student looking for an internship for Spring 2018? We have a project involving real-time API's and webhooks that you might find interesting. Read on to know what we do here at CX Social and what the project is about.</p>

<h2 id="what-do-we-do%3F">What do we do?</h2>

<p>The Clarabridge CX Social team builds a customer care tool for social media. Our clients use our software to be able to respond to the incoming questions and complaints on their Facebook pages, Twitter accounts, Instagram profiles, a.o. These clients often have a high volume of messages, on several social profiles. We try to make those people’s lives easier by offering automation tools, smart routing of messages and reply suggestions, among others.
<a href="https://developers.engagor.com/team">Read more about what we do</a>.</p>

<p>As of February 2018, we have room for one or more enthusiastic interns to join us for (at least) a couple of weeks <em>(preferably 4 days a week, any time between February 2017 to June 2018)</em>, to work as part of the CX Social development team.
As an intern you are an integral part of the R&amp;D team working on different parts of the application using technologies like PHP, React, MySQL, Redis, memcached, ElasticSearch, RabbitMQ, a.o. The team consists of a designer, front-end developer, data scientist, and several system engineers &amp; full-stack web developers.
We are looking for a student with interest and knowledge of mainly back-end technologies, and some front-end knowledge.</p>

<p>Want to know more about what it’s like to do an internship here? Read about <a href="https://engagor.github.io/blog/2017/06/01/internship-gheerwijn-cx-social-developer/">Gheerwijn’s experiences</a> or the <a href="https://engagor.github.io/blog/2017/06/30/internship-achievements/">Achievements project intern Cedric is currently working on</a>.</p>

<h2 id="the-project%3A-webhooks-api">The Project: Webhooks API</h2>

<p>CX Social has an Rest (oAuth JSON) API used by several of our clients. Its documentation is publicly available on our <a href="https://developers.engagor.com">developer site</a> so have a look to see what’s possible with it.<br />
Its uses include displaying important social profile metrics on own websites, two-way syncing of data from the CX Social CRM to other (in-house or 3rd party) CRM’s (like Salesforce, a.o.). It’s also being used to display curated social mentions on own sites, or to combine data from CX Social with data from other tools on internal dashboards.</p>

<p>Today, the API is used in a <code>PULL</code> model only, where clients (periodically) request information from our API. This internship project involves a significant update to allow <code>PUSH</code> webhooks to be send to our clients.<br />
Clients have been requesting this feature, and are eager to start using it, to be notified of new data (e.g. new tweets), or updates to data (e.g. when a certain social contact’s information is filled in) in real-time.
The project would take inspiration from the <a href="https://developers.facebook.com/docs/graph-api/webhooks">Facebook Webhooks API</a>, <a href="https://dev.twitter.com/webhooks">Twitter Webhooks API</a>, or <a href="https://api.slack.com/custom-integrations/outgoing-webhooks">Slack’s Outgoing Webhooks API</a> and take into account other <a href="https://restful.io/webhooks-dos-and-dont-s-what-we-learned-after-integrating-100-apis-d567405a3671">common do's and don'ts regarding webhooks</a>.</p>

<p>It consists of the following features:</p>

<ul>
<li>Creating &amp; updating webhook-subscriptions (defining which webhooks should be delivered where). 

<ul>
<li>This should be possible via an API, as well as a web-interface;</li>
<li>Configured delivery URL’s should be checked for ownership by verification with configured handshake;</li>
<li>Configured delivery URL’s should be checked for validity of their SSL certificates;</li>
<li>Several types of subscriptions will be needed (i.e. subscribing to “account” updates, and subscribing to “user” updates);</li>
</ul></li>
<li>A robust webhook delivery system, consisting of:

<ul>
<li>Re-delivery when the delivery URL’s is unresponsive;</li>
<li>Trying to guarantee exactly-once delivery;</li>
<li>Signed webhook payloads, so receivers can verify the origin of the request;</li>
<li>Notifying the API user via email when their delivery URL continues to be unresponsive;</li>
</ul></li>
<li>Implementing the event-log that eventually triggers the webhooks:

<ul>
<li>Making sure changes in the CX Social code base trigger an event to the webhooks system;</li>
<li>Distribution of events to the right subscriptions</li>
</ul></li>
<li>Monitoring of the system to:

<ul>
<li>Be alerted when webhook delivery is running behind.</li>
</ul></li>
</ul>

<p><center>
<img src="/images/2017-09-27-internships-webhooks-api/slow-delivery.gif" alt="Slow Delivery" /><br />
<small>Our future clients, when their webhooks aren't delivered on time.</small>
</center></p>

<p>Together with the CX Social development team, you as an intern are responsible for choosing the right technologies &amp; architecture. For those interested in backend technologies, this will be an exciting project, that you can help shape, build and deploy to production.</p>

<h2 id="interested%3F">Interested?</h2>

<p>We are looking for someone to join us in the Gent, Belgium office of Clarabridge, located at <a href="https://www.google.be/maps/place/CX+Social/@51.0597245,3.7213322,17z/data=!3m1!4b1!4m5!3m4!1s0x47c37138e71c8617:0x314cae371e7de8a5!8m2!3d51.0597245!4d3.7235209">Grauwpoort 1, 9000 Gent</a>.
Does this seem like a fun challenge for you? Please reach out to <a href="&#x6d;&#97;&#105;l&#x74;&#x6f;&#58;&#106;&#x75;&#x72;&#114;&#105;a&#x61;&#110;&#46;p&#x65;&#x72;&#115;&#121;&#x6e;&#x40;&#99;&#108;a&#x72;&#x61;&#98;&#114;&#x69;&#x64;&#103;&#101;&#x2e;&#x63;&#111;&#109;">jurriaan.persyn@clarabridge.com</a> with your details and we can set-up an interview to see if there’s a fit.</p>

<p><center>
<img src="/images/2017-09-27-internships-webhooks-api/thumbs.jpg" alt="Toppie" /><br />
<small>Our future clients, when you've implemented this cool feature.</small>
</center></p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Building a sliding window rate limiter with Redis]]></title>
            <link href="/blog/2017/05/02/sliding-window-rate-limiter-redis"/>
            <updated>2017-05-02T14:00:00+00:00</updated>
            <id>/blog/2017/05/02/sliding-window-rate-limiter-redis</id>
            <content type="html"><![CDATA[<p>For our Instagram crawler we needed a system to keep track of the amount of API calls we did to prevent us from hitting the rate limits. We could of course perform our HTTP requests without checking rate limits upfront, and wait until we get a <code>429 OAuthRateLimitException</code> from Instagram, but that would exhaust our tokens and block us from talking efficiently to their API.</p>

<p><img src="/images/2017-05-02-sliding-window-rate-limiter-redis/429.jpg" alt="Too many cats" /></p>

<blockquote>
  <p>All rate limits on the Instagram Platform are controlled separately for each access token, and on a sliding 1-hour window.</p>
  
  <p><a href="https://www.instagram.com/developer/limits">Instagram API rate Limits</a></p>
</blockquote>

<p>We're allowed to do 5000 API calls per access token each hour.</p>

<p><img src="/images/2017-05-02-sliding-window-rate-limiter-redis/slidingwindow.png" alt="Sliding window ratelimiting visualisation" /></p>

<p>Every point on the axis represents an API call. The sliding window is an hour in this case. Every time we do an API call we add the timestamp (in microseconds) of the API call to a list. In pseudocode:</p>

<pre><code class="js">timestamps.push(Date.now());
</code></pre>

<p>When we're about to do an API call in our crawler we need to check if we're allowed to do one:</p>

<ol>
<li>How many calls did we do in the last hour?</li>
</ol>

<pre><code class="js">callsInTheLastHour = timestamps.filter(timestamp =&gt; timestamp &gt; now - slidingWindow);
count = callsInTheLastHour.length
</code></pre>

<ol start="2">
<li>How many can we still do?</li>
</ol>

<p>After we calculated the amount of API calls we did in the last hour we can calculate the remaining API calls:</p>

<pre><code class="js">remaining = maxCallsPerHour - count;
</code></pre>

<p>Let's say we did <code>4413</code> API calls in the last hour then we're allowed to do <code>587</code> more at this moment.</p>

<p>Great, we got our algorithm. Now we need some kind of database to store a list of timestamps grouped per access token. Maybe we could use MySQL or PostgreSQL? Yes, we could but then we would need a system that periodically removes outdated timestamps since neither MySQL or PostgreSQL allow us to set a time to life on a row. What about <a href="http://memcached.org/">Memcached</a>? Yes, that's also an option. Sadly Memcached doesn't have the concept of an array or list (we could serialize an array using our favourite programming language). We can do better. What about <a href="https://redis.io/">Redis</a>? Yes, I like where this is going. Redis is a key/value store that supports lists, sets, sorted sets and more.</p>

<p>We're ready to translate our algorithm to Redis commands. Assuming you already have Redis installed, start a server: <code>$ redis-server</code>. If you're on a mac, you can just <code>$ brew install redis</code> to get it.</p>

<p>We're going to use a <a href="https://redis.io/commands/#sorted_set">sorted set</a> to hold our timestamps because it fits our needs.</p>

<pre><code>&gt; MULTI
&gt; ZREMRANGEBYSCORE $accessToken 0 ($now - $slidingWindow)
&gt; ZRANGE $accessToken 0 -1
&gt; ZADD $accessToken $now $now
&gt; EXPIRE $accessToken $slidingWindow
&gt; EXEC
</code></pre>

<p>Let's break it down:</p>

<ul>
<li><code>MULTI</code> to mark the start of a transaction block. Subsequent commands will be queued for atomic execution using <code>EXEC</code>.</li>
<li><code>ZREMRANGEBYSCORE $accessToken 0 ($now - $slidingWindow)</code> to remove API call timestamps that were done before the start of the window.</li>
<li><code>ZRANGE $accessToken 0 -1</code> to get a list of all API call timestamps that happened during the window.</li>
<li><code>ZADD $accessToken $now $now</code> to add a log for the current API call that we're about to do.</li>
<li><code>EXPIRE $accessToken $slidingWindow</code> to reset the expiry date for this sorted set of timestamps (for the current OAuth Token).</li>
<li><code>EXEC</code> will execute all previously queued commands and restore the connection state to normal.</li>
</ul>

<p>Instead of using the actual OAuth access tokens (and duplicating them to Redis), you might want to use an identifier or hash of the token instead as <code>$accessToken</code>. It serves as the key for our Redis sorted set. Also note that, in the same transaction as reading the list of timestamps, we <em>add</em> a new timestamp to the list (the <code>ZADD</code> command). We do this because this is being used in a distributed context (we have many workers performing API calls), and we don't want to write when we already exceeded our limits.</p>

<p>In PHP this might look like this:</p>

<pre><code class="php">// composer require predis/predis
require_once __DIR__ . '/vendor/autoload.php';

$maxCallsPerHour = 5000;
$slidingWindow = 3600;

$now = microtime(true);
$accessToken = md5('access-token');

$client = new Predis\Client();
$client-&gt;multi();
$client-&gt;zrangebyscore($accessToken, 0, $now - $slidingWindow);
$client-&gt;zrange($accessToken, 0, -1);
$client-&gt;zadd($accessToken, $now, $now);
$client-&gt;expire($accessToken, $slidingWindow);
$result = $client-&gt;exec();

// The second command inside the transaction was ZRANGE,
// which returns a list of timestamps within the last hour.
$timestamps = $result[1];

$remaining = max(0, $maxCallsPerHour - count($timestamps));

if ($remaining &gt; 0) {
    echo sprintf('%s: Allowed and %d remaining', $now, $remaining) . PHP_EOL;
} else {
    echo sprintf('%s: Not allowed', $now) . PHP_EOL;
}
</code></pre>

<p>To conclude all of this, and to make this work within our codebase, we put this all nicely in a class, behind an interface <code>RateLimiter</code>:</p>

<pre><code class="php">&lt;?php

namespace CXSocial\RateLimiter;

interface RateLimiter
{
    /**
     * Request the remaining ratelimit points
     *
     * @param RateLimitedResource $rateLimitedResource
     *
     * @throws SorryRateLimitUnavailable
     *
     * @return int
     */
    public function remaining(RateLimitedResource $rateLimitedResource);
}
</code></pre>

<p>This allows us to write code that doesn't couple to implemention too much. This has been working like a charm for us! We're huge fans.</p>

<p><img src="/images/2017-05-02-sliding-window-rate-limiter-redis/fan-limit.gif" alt="HUGE FAN" /></p>
]]></content>
        </entry>
    </feed>