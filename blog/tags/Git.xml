<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[CX Social Dev Blog]]></title>
    <link href="/blog/tags/Git.xml" rel="self"/>
    <link href="/"/>
    <updated>2017-02-17T09:38:48+00:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Some tips for a better Git history]]></title>
            <link href="/blog/2017/01/24/some-tips-for-a-better-git-history"/>
            <updated>2017-01-24T15:00:00+00:00</updated>
            <id>/blog/2017/01/24/some-tips-for-a-better-git-history</id>
            <content type="html"><![CDATA[<p>We're all heavy Git users in the CX Social development team. Honestly, we couldn't survive without it, as some of us are located across the planet, and we also use GitHub as our primary source of information, even when talking to other teams like the "Customer Support" team. Here's some small tips we learned along the way, when it comes to keeping your Git history clean.</p>

<h2 id="%60git-log%60-like-a-boss"><code>git log</code> like a boss</h2>

<p>I personally like to see everything there is to see about my git history. That's why I have an alias for <code>git log</code> that upgrades it with two default flags:</p>

<pre><code class="sh">git log --decorate --name-status
</code></pre>

<p>The <code>--decorate</code> flag shows ref names next to commits, meaning that you can see where <code>HEAD</code> points, and where your current (and remote) branches are pointing.</p>

<p>The <code>--name-status</code> flag activates the functionality to display which files were changed in that commit, below your commit message. This is great to see what changed in a commit, at first glance.</p>

<h2 id="writing-proper-commit-messages">Writing proper commit messages</h2>

<p>Another great tip, and maybe the best thing you'll take away from this blog post, actually comes from <a href="http://chris.beams.io/posts/git-commit/">another blogpost</a> which talks about writing great <code>git commit</code> messages. If you haven't read that post, go read it now, it's awesome. The main things I took away from it are these:</p>

<ul>
<li>use a proper text editor (like Vim) for writing your commit messages</li>
<li>write a commit subject as the first line, which complete this sentence:
<code>if applied, this commit will...</code></li>
<li>keep a blank line between the subject and what follows</li>
<li><strong>always</strong> write a commit body with <strong>what</strong> changed, and <strong>why</strong> you changed it.</li>
</ul>

<p>If you're too stubborn to write your commit messages using a decent text editor, here's a trick for you: you can use the <code>-m</code> flag on your command line more than once, to create paragraphs, e.g.:</p>

<pre><code class="sh">git commit \
-m "Add a second Hyperdrive as a backup" \
-m "When being followed by an imperial fighter, we want to be able to jump to hyperspace even though our first drive fails." \
-m "We're afraid this might cause some more radiation than expected."
</code></pre>

<p>But still, really consider using a text editor.</p>

<h2 id="distributed-versioning">Distributed versioning</h2>

<p>Git is a distributed versioning system, which means that it's designed to work offline, without a connection to the remote. We might as well exploit that to have great git history.</p>

<ul>
<li><code>git checkout</code> your own feature branch to work on something</li>
<li>don't <code>push</code> or <code>pull</code> while working on your feature. This gives you the advantage that you can <code>amend</code> your commit messages if you made a mistake, or that you can even <code>rebase</code> or <code>squash</code> your commits for clarity.</li>
<li>when you're done, push your branch. If you're working alone on your feature branch, this will work fine and you're done. If there are other people working on the same branch, don't panic and proceed to the next step</li>
<li><code>git pull --rebase origin {branch-name}</code> and then push</li>
</ul>

<p>As I mentioned before, <strong>not</strong> pushing or pulling, and still being able to work is a great feature of git. It means that you can work offline and do everything as if you were the only developer working on a project. You can undo mistakes you made in git, say, you forgot to include a file in a commit. Just <code>git commit --amend</code> it to your liking. Just don't go around and change parts of history that were already pushed.</p>

<p>Now the <code>--rebase</code> part in the <code>git pull</code> step is where it gets interesting. What this does, is undo everything you did since the last time you pulled the branch. Then it pulls from the remote, so that it's a fast-forward without conflicts with 100% certainty. And then it will apply your commits to that. This means that if you changed something, and someone else changed the same thing, you will have a rebase conflict. Which is great! You can now just fix your own conflict, and the history will still be linear! This also means that you will have to fix your own conflicts from now, instead of fixing other people's conflicts. Go on and push your branch when your done.</p>

<h2 id="merging-master-in-your-feature-branch">Merging master in your feature branch</h2>

<p>In analogy with what I said before, you can look at your feature branch as an "isolated" place where you can work on your feature in separation of everything that happens in other branches. Just do what you wanted to do, and never merge any branch into it, or at least minimize the amount of times you merge in case you really really have to.</p>

<p>The advantage this gives you, is great linear history in your feature branch, which <strong>only</strong> applies to that feature, which makes it easy to review or merge into other branches. This is even more true if you use the <code>git pull --rebase</code> feature from the previous tip.</p>

<p>Now, when your feature is ready and there are merge conflicts between your feature branch, and the branch you want to merge it into, e.g. <code>master</code>, you can solve that easily. Merge master in your branch once, and fix your own conflicts. Then merge your branch into master. There are some rebase tricks you can do here to keep linear history too, but I prefer to still merge branches when a feature is done.</p>

<h2 id="further-reading">Further Reading</h2>

<ul>
<li><a href="http://chris.beams.io/posts/git-commit/">How to Write a Git Commit Message</a></li>
<li><a href="https://git-scm.com/book/en/v2/Distributed-Git-Distributed-Workflows">GitBook chapter on Distributed Workflows</a></li>
<li><a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a></li>
</ul>

<p>That's it! Enjoy your clean git logs!</p>
]]></content>
        </entry>
    </feed>