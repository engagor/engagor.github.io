<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[CX Social Dev Blog]]></title>
    <link href="/blog/categories/Functional Programming.xml" rel="self"/>
    <link href="/"/>
    <updated>2018-09-28T07:48:10+00:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Lambda To The Rescue: Recursion]]></title>
            <link href="/blog/2018/06/27/lambda-recursion"/>
            <updated>2018-06-27T14:00:00+00:00</updated>
            <id>/blog/2018/06/27/lambda-recursion</id>
            <content type="html"><![CDATA[<p><strong>This is the third post in a series about using Functional Programming concepts to make your Object Oriented code more comprehensible. Start <a href="/blog/2018/03/02/lambda-lists-to-wrap-failure">here</a> if you want to read the whole thing.</strong></p>

<h3 id="procedural-and-declarative-styles">Procedural and Declarative styles</h3>

<p>Most programming languages have language structures to loop through lists and do interesting stuff with those lists. When you're used to programming using one of those languages, it can be pretty terrifying to have your basics taken away from you when you jump into a functional programming language like Scheme or Haskell. Let's see what the problem is that functional languages have with loops and how they solved it.</p>

<p>Let's look at a pretty standard loop in PHP that counts how many words are in a list:</p>

<pre><code class="php">function countWordsInList(array $listOfWords)
{
    $count = 0;

    foreach ($listOfWords as $word) {
        $count++;
    }

    return $count;
}
</code></pre>

<p>Of course, this is an overly simple example (and you should probably use <code>count()</code>), but you get the point. Now, things get difficult, because there are no loops like this <code>foreach</code> in a lot of functional programming languages. Why, you ask? Because most of them either don't allow you to reassign variables (which makes the loop pretty useless), and, in fact, some of them disallow side-effects altogether. Let's see how we do this in Haskell instead:</p>

<pre><code class="haskell">countWordsInList :: [String] -&gt; Int
countWordsInList [] = 0
countWordsInList (x:xs) = 1 + countWordsInList xs
</code></pre>

<p>OK, stop. 🤔 What the hack is happening here?</p>

<ul>
<li>On the first line, we have the type definition of our function: It takes a list of strings <code>[String]</code> and it returns an <code>Int</code>. It's a good practice to write it (it helps you think), but Haskell's compiler can infer it most of the time.</li>
<li>Then we define a "base" case: <code>countWordsInList</code> returns <code>0</code> for an empty list <code>[]</code>.</li>
<li>Then we say that for a list with at least one word <code>x</code> and possibly other words <code>xs</code>, we'll return <code>1</code> and add the result of the recursive call to the same function, with the rest of the list of words (the whole list without the first word).</li>
</ul>

<p>As you can see, in the PHP example we told the machine what to do with the list to get to a result. In the Haskell example, we declared what the result was, and some variables just had to be filled in. You could say that no computation needed to happen, just substitution.</p>

<pre><code class="haskell">countWordsInList ["foo", "bar", "baz"] = 1 + countWordsInList ["bar", "baz"]
countWordsInList ["foo", "bar", "baz"] = 1 + 1 + countWordsInList ["baz"]
countWordsInList ["foo", "bar", "baz"] = 1 + 1 + 1 + countWordsInList []
countWordsInList ["foo", "bar", "baz"] = 1 + 1 + 1 + 0
countWordsInList ["foo", "bar", "baz"] = 3
</code></pre>

<h3 id="recognizing-a-pattern">Recognizing a Pattern</h3>

<p>Let's try and write a function to sum all numbers in a list of integers:</p>

<pre><code class="haskell">sum' :: [Int] -&gt; Int
sum' [] = 0
sum' (x:xs) = x + sum' xs
</code></pre>

<p>OK, so:</p>

<ul>
<li>We'll call our function <code>sum'</code> because <code>sum</code> already exists.</li>
<li>We want <code>sum'</code> to take a list of integers <code>[Int]</code> and we'll return the sum of all those as an <code>Int</code>.</li>
<li>We'll start with the simplest case: an empty list will have the sum <code>0</code>.</li>
<li>In all other cases, we'll take the first <code>Int</code> in the list, and add it to the sum of all other items in the list.</li>
</ul>

<p>💡 Does that make you think of something?</p>

<p>You're right, this looks <strong>a lot</strong> like the previous example <code>countWordsInList</code>. And that's what other functional programmers thought when they were doing stuff like this. What if we could make an abstraction over this?</p>

<pre><code class="haskell">xxxxx [] = __value__
-- either return something for an empty list

xxxxx (x:xs) = __function__ x (xxxxx xs)
-- or take the first item of the list and combine
-- it with the recursive call with the rest of the list
</code></pre>

<p>Let's try. With the above blueprint, we can see that we need to create a function that</p>

<ol>
<li>takes a <code>__function__</code> that combines a value with the next</li>
<li>takes a <code>__value__</code> that is the default for empty lists</li>
<li>abstracts away the recursive call and returns the endresult;</li>
</ol>

<p>Let's define its type:</p>

<pre><code class="haskell">fold' :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a
</code></pre>

<ul>
<li>we'll call our function <code>fold'</code></li>
<li><code>(a -&gt; b -&gt; a)</code> first parameter is a function that takes a value of type <code>a</code> and type <code>b</code> and returns a value of type <code>a</code></li>
<li><code>-&gt; a</code> second parameter is the default value of type <code>a</code></li>
<li><code>-&gt; [b]</code> third parameter is a list of values to loop over, they all have type <code>b</code></li>
<li><code>-&gt; a</code> the return value will be of type <code>a</code></li>
</ul>

<p>Now we can start writing. We know that if the list we got is empty, we can just return the default value:</p>

<pre><code class="haskell">fold' _ def [] = def
</code></pre>

<p>The <code>_</code> means "we don't care about that value". It doesn't matter what the function is; if the list is empty, we don't need it. What if the list is not empty, but contains one or more elements? Let's use the combining <code>func</code> to combine the first item of the list with the result of the recursive call to the <code>fold'</code> function with exactly the same parameters (except for the "list", we just pass everything but the first element that we already used):</p>

<pre><code class="haskell">fold' func def (x:xs) = func x (fold' func def xs)
</code></pre>

<p>We apply the <code>func</code> to the first element and the result of the recursive call to our <code>fold'</code> function with all the same parameters, except for the list. There we just pass on the rest of the list (so without the first element that we already used).</p>

<p>Combined, that is:</p>

<pre><code class="haskell">fold' :: (b -&gt; a -&gt; a) -&gt; a -&gt; [b] -&gt; a
fold' _ def [] = def
fold' func def (x:xs) = func x (fold' func def xs)
</code></pre>

<p>Let's see if it works! Remember <code>countWordsInList</code>?</p>

<pre><code class="haskell">countWordsInList :: [String] -&gt; Int
countWordsInList [] = 0
countWordsInList (x:xs) = 1 + countWordsInList xs
</code></pre>

<p>We'll rewrite it using the <code>fold'</code> function:</p>

<pre><code class="haskell">countWordsInList :: [String] -&gt; Int
countWordsInList list = fold' (\word count -&gt; count + 1) 0 list
</code></pre>

<p>We'll fold over the <code>list</code> with a function that takes the next <code>word</code> and the current <code>count</code>, and returns <code>count + 1</code>. The stuff that's written between parens is a lambda (anonymous function) and looks like this <code>(\params -&gt; body)</code>. The default value for our <code>fold'</code> is <code>0</code>. When we use it, it gives expected results:</p>

<pre><code class="haskell">countWordsInList ["foo", "bar", "baz", "qux"]
-- 4

countWordsInList []
-- 0

countWordsInList ["foo"]
-- 1
</code></pre>

<p>How about the <code>sum</code> function that we made earlier?</p>

<pre><code class="haskell">sum' :: [Int] -&gt; Int
sum' = fold' (+) 0
</code></pre>

<p>Let's try it out:</p>

<pre><code class="haskell">sum' [1, 2, 3, 4]
-- 10

sum' []
-- 0

sum' [5]
-- 5
</code></pre>

<p>That seems to work... But wait... We wrote the definition <code>sum' = fold' (+) 0</code> without a list? Isn't this function definition incomplete? Yes. In Haskell, like in math, you can omit things that happen on both sides of the equals sign. Compare it to <code>3 + 4 = 1 + 2 + 4</code>. You could just as well write <code>3 = 1 + 2</code>. It's the same thing in Haskell. <code>sum' list = fold' (+) 0 list</code> is the same as <code>sum' = fold' (+) 0</code>.</p>

<p>As an exercise, let's do one more. We'll try to write a function that finds the maximum value of a list of positive integers, and returns <code>0</code> otherwise:</p>

<pre><code class="haskell">maximum' :: [Int] -&gt; Int
maximum' = fold' (\next current -&gt; if next &gt; current then next else current) 0
</code></pre>

<pre><code class="haskell">maximum' []
-- 0

maximum' [1, 2, 3, 5, 3, 2, 10, 0, 1]
-- 10

maximum' [42]
-- 42
</code></pre>

<p>If you want to use folds in Haskell, you certainly shouldn't write them yourself 😅 - they already exist. Check out <a href="https://wiki.haskell.org/Foldr_Foldl_Foldl'">the documentation</a> for <code>foldl</code>, <code>foldr</code> and <code>foldl'</code>.</p>

<h3 id="transforming-a-list-to-another-list">Transforming a list to another list</h3>

<p>Let's say we have a list of Users, and we wanted to only have a list of their ages. The above methods could help us do that, but it would be quite tedious. Let's try writing a function for it ourselves.</p>

<pre><code class="haskell">data User = User { name :: String
                 , age :: Int
                 } deriving (Show)

ages :: [User] -&gt; [Int]
ages [] = []
ages (u:us) = age u : ages us
</code></pre>

<p>Again, we make sure we got the base case of an "empty list of users" covered: we'll just return an empty list of ages. Then we really need to start thinking. We'll just get what we need for the first value of the input list, and prepend that to the result of the recursive call with the rest of the list (just like what we did with the folds). Let's see what that gives us:</p>

<pre><code class="haskell">ages []
-- []

ages [ User {name="toon", age=29}, User {name="jenne", age=30} ]
-- [29,30]

ages [ User {name="toon", age=29} ]
-- [29]
</code></pre>

<p>It seems to work!</p>

<p>What if we had a list of ages, and we wanted to know how many years these people still had left to live. Let's oversimplify again, and subtract their age from <code>100</code>.</p>

<pre><code class="haskell">yearsLeft :: [Int] -&gt; [Int]
yearsLeft [] = []
yearsLeft (x:xs) = 100 - x : yearsLeft xs
</code></pre>

<p>Again, we take the first element of the list, do something with it, and recurse on the rest of the list. That looks a lot like the "age" example, doesn't it?</p>

<p>Well... there's an abstraction that can be made again. The "generic" function for doing things like this should look like so:</p>

<pre><code class="haskell">xxxxx [] = []
-- an empty input list results in an empty output list

xxxxx (x:xs) = __function__ x : (xxxxx xs)
-- take the first item of the list and do something with it
-- recurse on the rest of the list and append results.
</code></pre>

<p>Let's define its type:</p>

<pre><code class="haskell">map' :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>

<p>Let's name our function <code>map'</code>, it takes a function from type <code>a</code> to type <code>b</code> and a list with <code>a</code>s. It then returns a list of <code>b</code>s. In the base case, it should return an empty list:</p>

<pre><code class="haskell">map' _ [] = []
</code></pre>

<p>In other cases, it should take the first item of the list, apply the function to it, and append the result of the recursive call:</p>

<pre><code class="haskell">map' func (x:xs) = func x : map' func xs
</code></pre>

<p>So, we get this:</p>

<pre><code class="haskell">map' :: (a -&gt; b) -&gt; [a] -&gt; [b]
map' _ [] = []
map' func (x:xs) = func x : map' func xs
</code></pre>

<p>Let's try it out: we want to write a function that takes a list of <code>Int</code>s and returns the same list but with <code>1</code> added to each element.</p>

<pre><code class="haskell">plusOne :: [Int] -&gt; [Int]
plusOne = map' (+ 1)
</code></pre>

<pre><code class="haskell">plusOne []
-- []

plusOne [1, 2, 3]
-- [2,3,4]

plusOne [3]
-- [4]
</code></pre>

<p>Cool! So now we have generalizations over some of these recursive functions! There are others to be found. I'll leave that to the reader to find out about.</p>

<h3 id="back-to-oop">Back to OOP</h3>

<p>You can probably see that these abstractions have their value. E.g.: <code>map</code> lets you use a function that applies to one thing on a whole list of those things. Even better, it lets you do it in a totally declarative style. You don't need to worry about state or changing variables. You don't need to keep counter values. Nothing. It's totally transparent. For me, this results in a huge reduction of mental overhead. I know, I talk a lot about that, but it's important to me. The same thing is true for the <code>fold</code>s. It's another way of thinking about loops that works really well for me.</p>

<p>When we get back to e.g. PHP now, I see many cases where a <code>map</code> or <code>fold</code> would be great. Implementing them ourselves isn't necessary (luckily), because they already exist in practically every programming language.</p>

<p>One more thing. The above implementations -which actually work really great in functional programming languages- wouldn't work in languages like PHP. The reason is simple: we would get stack overflows pretty quickly; In functional programming languages, there are things called tail call optimizations that can be made. They make sure that you don't blow the stack, even if you recurse a thousand times. This is not really possible in PHP functions right now. Try it out! But after it, just use <code>array_map()</code> and <code>array_reduce()</code> if you want to do stuff like this 😉!</p>

<p>Happy programming y'aλλ! 🖖</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Lambda To The Rescue: Pure Functions]]></title>
            <link href="/blog/2018/06/04/lambda-pure-functions"/>
            <updated>2018-06-04T10:00:00+00:00</updated>
            <id>/blog/2018/06/04/lambda-pure-functions</id>
            <content type="html"><![CDATA[<p><strong>This is the second post in a series about using Functional Programming concepts to make your Object Oriented code more comprehensible. Start <a href="/blog/2018/03/02/lambda-lists-to-wrap-failure">here</a> if you want to read the whole thing.</strong></p>

<p>Whenever you read up on functional programming on the internet, it's common to come across words like "pure" and "transparent", and for good reason. Let's explore their meaning in the functional programming world. 🕵️‍♂️</p>

<h2 id="%F0%9F%92%8E-purity">💎 Purity</h2>

<p>Let's pretend we need to represent the number of cylinders in an engine <code>2</code> in our code. In a normal scenario, we would assign it to a variable and be done with it. We'll use <a href="https://www.haskell.org/">Haskell</a>, a pure functional language.</p>

<pre><code class="haskell">cylinders :: Int
cylinders = 2
</code></pre>

<p>In the example, we start with a type annotation. You can read the first line as "cylinders <strong>is an</strong> Int". Then we write our statement.</p>

<p>Now, whenever we need the number of cylinders for computation, we could just get it from the variable right? Sure! Let's try something else, since we're talking about "pure" functions. Let's try to use a function that doesn't take any input and always returns the number of cylinders, instead of a variable:</p>

<pre><code class="haskell">cylinders :: Int
cylinders = 2
</code></pre>

<p>Wait? WAT? That is exactly the same?</p>

<p>Yes, in Haskell, a function without parameters is the same as a value. And that's logical right? No computation needs to happen when there's no input... right?</p>

<p>Well... Let me disappoint you:</p>

<pre><code class="php">function cylinders()
{
    echo rand();

    return 2;
}
</code></pre>

<p>In PHP, and in practically any other language, you can do things in functions that have side effects. In this case</p>

<ul>
<li>we created output on the <code>stdout</code></li>
<li>we called <code>rand()</code> which in turn tried to create a random number by reading from a randomness source</li>
</ul>

<p>Of course this can result in A LOT of unexpected behaviour. By just looking at the function, you can't always immediately see what's going to happen. And this is what the word <code>pure</code> refers to. This function has "side effects", so it's not "pure".</p>

<p>In Haskell though, if you want to do side effects within a function it will be marked with an <code>IO</code> tag. In fact, this is a type that behaves a bit like an environment. Getting a random number and echo'ing it requires <code>IO</code>, so the type can't just be <code>Int</code>, it's <code>IO Int</code>.</p>

<pre><code class="haskell">cylinders :: IO Int
</code></pre>

<p>This way, you can always clearly see, just by looking at the types, that the function has side effects, and thus is not "pure".</p>

<h2 id="%F0%9F%91%93-transparency">👓 Transparency</h2>

<p>While these terms are used interchangibly, in my book the word "transparency" makes this very clear: you can "look straight through" a function.</p>

<pre><code class="haskell">double :: (Num a) =&gt; a -&gt; a
double x = 2 * x
</code></pre>

<p>For every numeric value, we can calculate its <code>double</code>. You could really write this as a complete mapping from every number to its double:</p>

<pre><code class="haskell">double :: (Num a) =&gt; a -&gt; a
double 0 = 0
double 1 = 2
double 2 = 4
double 3 = 6
double 4 = 8
-- ... etcetera
</code></pre>

<p>As you can see, we reduced the function to (essentially) "values" again, as in the first example of this post. Calls to transparent functions could in theory be replaced by their values. In functional programming jargon this is called "referential transparancy".</p>

<p>A lot of functions can be made in an entirely transparent way, even quite complex things like parsing structured text or doing extensive computation.</p>

<h2 id="%F0%9F%A4%A9-consequences">🤩 Consequences</h2>

<h4 id="reduced-mental-overhead">Reduced mental overhead</h4>

<p>As you can imagine, being able to reason about functions as "values" makes things <em>much</em> easier. Otherwise you have to deal with side effects that can change the world while you just expected an Integer representing the number of cylinders in a motorcycle. The same goes for the other case, where an <code>IO Int</code> lets you know instantly that there will be stuff happening behind the curtains, and you're not getting your <code>Int</code> for free.</p>

<h4 id="in-fp-as-well-as-oop-environments">In FP as well as OOP environments</h4>

<p>Even in OOP environments I always try to see which parts of the code that I'm writing can be written as pure functions, so that they can be extracted to functions that represent values. E.g. processing incoming social media posts to a unified format of a post that our system understands is essentially a "transparent" operation. It's just a transformation of data to a certain format. The fact that this function is pure makes it very easy to reason about: we can essentially just think about the post in it's basic form (inline the function as value).</p>

<p>Now that I'm thinking about it: it would be GREAT if static analysis could detect side effects in functions... What do you think? 🤯</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Lambda To The Rescue: Lists to wrap failure]]></title>
            <link href="/blog/2018/03/02/lambda-lists-to-wrap-failure"/>
            <updated>2018-03-02T11:00:00+00:00</updated>
            <id>/blog/2018/03/02/lambda-lists-to-wrap-failure</id>
            <content type="html"><![CDATA[<p><strong>This is the first post in a series about using Functional Programming concepts to make your Object Oriented code more comprehensible. Hang tight for more.</strong></p>

<h2 id="readability">Readability</h2>

<p>When we're reading code, one of the most important blocking factors is cognitive overhead. Minimize it, and your code instantly becomes easier to read and understand. Or is it the other way 'round? After some years of playing with functional programming languages in my spare time, I saw some things that functional programming does great in this field. One of them involves lists.</p>

<p>As you might know, lists are among the most important datastructures in functional programming, if not the most important. There's even a whole family of programming languages that took their name from them. Looking at you <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> 😘!</p>

<p>Let's dive in with a typical legacy PHP method discovered in the wild:</p>

<pre><code class="php">&lt;?php

function words($string)
{
    if (empty($string)) {
        return false;
    }

    return explode(' ', $string);
}

var_dump(words('')); // returns false
var_dump(words('foo bar baz')); // returns ['foo', 'bar', 'baz'];
</code></pre>

<p>The reason the <code>empty</code> check is there, apparently, is that <code>explode(' ', $s)</code> with an empty string will return <code>['']</code> a list with an empty string in it, which is really strange and non-desirable. Arguably, if the <code>$string</code> variable can't be empty, we should throw an exception. But let's say we want to explore our options here. Before I look into the body of a function, I always try to understand it as a black blox.</p>

<blockquote>
  <p>If I pass <code>words</code> a string, it returns an <code>array</code> of words in the string. Except that for empty strings, it will return <code>false</code>.</p>
</blockquote>

<p>Now, the "black box" already has some mystery to it. Why does it return <code>false</code>? Let's defer the answer to it, and check out if we can write the PHP7 type annotations for it.</p>

<pre><code class="php">function words(string $string): array
{
    // ...
}
</code></pre>

<p>Now, this is not correct. The exception that is made for empty strings can't be written as a type. In old-skool PHP they would've written a DocBlock like this:</p>

<pre><code class="php">/**
 * @param string $string
 * @return array|false depending on failure
 */
function words($string)
{
    // ...
}
</code></pre>

<p>But that is a type signature that is unrepresentable usinig PHP7 types. What if we would represent failure using an empty array?</p>

<pre><code class="php">function words(string $string): array
{
    if (empty($string)) {
        return array();
    }

    return explode(' ', $string);
}
</code></pre>

<p>Now the type signature just works. We turned "failure" into a valid result that we can work with. For instance, all code that works with the return value of this method can now just work with arrays. The type signature now tells a story about the function too:</p>

<blockquote>
  <p>If I pass <code>words</code> a string, it returns an <code>array</code> of words in the string.</p>
</blockquote>

<p>The base case where the string is empty is now logical: an empty string has no words, so a list of 0 words is returned.</p>

<h2 id="chaining-calls">Chaining calls</h2>

<p>Now, let's say we have a function <code>chars</code> that returns a list of chars in a string:</p>

<pre><code class="php">function chars(string $string): array
{
    if (empty($string)) {
        return array();
    }

    return str_split($string);
}
</code></pre>

<p>We're thinking we should be able to use this to list all the characters that appear within words. Would this work?</p>

<pre><code class="php">chars(words('foo bar baz'));
</code></pre>

<p>No... We get a fatal error <code>Fatal error: Uncaught TypeError: Argument 1 passed to chars() must be of the type string, array given</code>. Of course, the result of <code>words</code> is an array, which cannot be used as input to our <code>chars</code> function. Let's use <code>array_map</code>:</p>

<pre><code class="php">array_map(@chars, words('foo bar baz'));
</code></pre>

<p><em>don't worry about the <code>@</code>, it's a trick that I learned while working on <a href="https://github.com/mathiasverraes/lambdalicious/">lambdalicious</a>. <code>@</code> is PHP's error suppressing operator. In this case it allows us to write a function's name as a string, without using string notation, so that it's visually different from a string, BUT is interpreted by PHP as a string...</em></p>

<p>We get this:</p>

<pre><code class="php">[["f","o","o"],["b","a","r"],["b","a","z"]]
</code></pre>

<p>Of course, after mapping <code>chars</code> over the words, this is what we get... But actually, we wanted this:</p>

<pre><code class="php">["f","o","o","b","a","r","b","a","z"]
</code></pre>

<p>So how do we get there? We "flatten" the arrays by using <code>concat</code>, which does not exist in php. Let's write it ourselves:</p>

<pre><code class="php">function array_concat(array $arrays): array
{
    return call_user_func_array(
        @array_merge,
        array_merge(array(array()), $arrays)
    );
}
</code></pre>

<p>Now we can use it to flatten the array:</p>

<pre><code class="php">array_concat(array_map(@chars, words('foo bar baz')));
</code></pre>

<p>TADAAAA 😆 We get what we wanted!</p>

<pre><code class="php">["f","o","o","b","a","r","b","a","z"]
</code></pre>

<p>Let's call this combination of <code>array_map</code> and <code>array_concat</code> <code>array_bind</code> for now:</p>

<pre><code class="php">function array_bind(array $array, $f)
{
    return array_concat(array_map($f, $array));
}
</code></pre>

<p><code>array_bind</code> takes an array of values, and a function that operates of one of those values and returns an array. It returns a new array of values.</p>

<pre><code class="php">array_bind(array_bind(array('foo bar baz'), @words), @chars);
// returns ["f","o","o","b","a","r","b","a","z"]
</code></pre>

<p>Now that we have the <code>array_bind</code> function, we can apply functions to something in an array, and the result will always be an array! What happens if we first bind <code>words</code> and then bind <code>chars</code> to an empty string?</p>

<pre><code class="php">array_bind(array_bind(array(''), @words), @chars); // returns []
</code></pre>

<p>We get an empty array back, which is great!</p>

<p>You saw me wrap the empty string in an array, to be able to use <code>array_bind</code>. This is an act of "providing context". The array serves as a context wrapper for results of the chained functions <code>words</code> and <code>chars</code>. We'll always get our result as an array. If anywhere in the process something fails, we get an empty array, otherwise we get an array with value(s) in it.</p>

<p>I must admit, this doesn't look really great. Let's take a look at how this works in <a href="https://www.haskell.org/">Haskell</a>, a pure functional language.</p>

<p>Now, this is the equivalent of what we wrote earlier on in PHP:</p>

<pre><code class="haskell">pure "" &gt;&gt;= words &gt;&gt;= chars
</code></pre>

<pre><code class="haskell">pure "foo bar baz" &gt;&gt;= words &gt;&gt;= chars
</code></pre>

<p>These return <code>[]</code> and <code>["f","o","o","b","a","r","b","a","z"]</code>, as expected, but how?</p>

<ul>
<li><code>pure</code> wraps the string in our "wrapper" list.</li>
<li><code>&gt;&gt;=</code> is the <code>bind</code> infix function; it takes the "wrapped" value on the left, and applies the function on the right to the wrapped value. It then returns a new wrapped value.</li>
<li><code>words</code> takes a <code>String</code> and returns a list of strings <code>[String]</code>, split by spaces. It's in Haskell's default module <code>Prelude</code>.</li>
<li><p><code>chars</code> is a function we made up, it takes a <code>String</code> and returns a list of strings <code>[String]</code>. By default, <code>String</code>s in Haskell are lists of <code>Char</code>s. To break up a given string in a list of strings that represent chars we need to map over the input string. The mapping function <code>(\x -&gt; [x])</code> gets a <code>Char</code> as input and returns a <code>String</code> by wrapping the given <code>Char</code> in a list; check it out:</p>

<pre><code class="haskell">chars :: String -&gt; [String]
chars s = map (\x -&gt; [x]) s
</code></pre></li>
</ul>

<p>As you can see, Haskell was made for this kind of stuff... It also reads a lot better than our PHP implementation.</p>

<h2 id="expanding-on-this-concept">Expanding on this concept</h2>

<p>The reason this doesn't really work in PHP is that we don't have infix operators at our disposal. I've seen <a href="https://github.com/phunkie/phunkie">libraries</a> that do something with method calls along these lines:</p>

<pre><code class="php">pure('foo bar baz')-&gt;bind(@words)-&gt;bind(@chars);
</code></pre>

<p>which already looks a lot better than what we came up with. Failure can be encapsulated. There's a lot less boilerplate code to read. There's no checking for empty arrays or failure, while it still behaves as we wanted.</p>

<ul>
<li><code>pure()</code> wraps the value in an object.</li>
<li><code>bind()</code> is equivalent to returning a new wrapper object with the result of the applied function to the previously wrapped value. Internally it could all work using <code>arrays</code>, but it could just as well be done differently.</li>
</ul>

<p>For now, we've always worked with functions that return a number of results, but this whole concept can just as well be used with functions that are supposed to return a single result, like integer division <code>div</code>:</p>

<pre><code class="php">function div(int $divident, int $divisor): WrappedValue
{
    if ($divisor === 0) {
        return nothing();
    }

    return pure(intdiv($divident, $divisor));
}
</code></pre>

<p>Now, we created an integer division function that doesn't throw <code>DivisionByZeroError</code> exceptions, but uses this system of <code>WrappedValue</code>s to wrap it's return value on success (using <code>pure</code>, equivalent to an array with a value) or on failure (using <code>nothing</code>, equivalent to an empty array). Now, if we want to square the result of this, we can just bind <code>square</code> to the result of the previous computation.</p>

<pre><code class="php">function square(int $number): WrappedValue
{
    return pure($number * $number);
}

var_dump(div(10, 2)-&gt;bind(@square)); // [25]
var_dump(div(10, 0)-&gt;bind(@square)); // []
</code></pre>

<p>As with the previous examples, we can now just focus on the order of computation, without the need to worry about failure in the in-between steps.</p>

<p>There are also ways to make this whole thing even more interesting by providing more info like error messages in case of failure.</p>

<h2 id="day-to-day-usage">Day-to-day usage</h2>

<p>I'm not saying this is perfect for everything in OOP by any means, but we might want to think about how we handle failure in our (legacy) systems. I sometimes see trees of exception handling and boolean/null-checks on return values. This is a third option (PHP doesn't have option types by default); In lots of ways, the classic <a href="https://en.wikipedia.org/wiki/Null_object_pattern">Null Object</a> pattern resembles this whole thing in a more Object Oriented way. In many functional programming languages this is actually the most widely used means of error handing. If you want to know more about it, I suggest reading up on <code>Functors</code>, <code>Applicatives</code>, and <code>Monads</code>. Scary names for new concepts, don't let them hold you back.</p>

<p>If you want to do the most simple and useful thing: think about how your functions behave. What goes in, what comes out? Writing the type annotations helps a lot. And of course, throwing exceptions is not a sin.</p>

<p>Happy programming y'aλλ! 👋</p>

<h2 id="what%27s-next%3F">What's next?</h2>

<p>Upcoming <em>lambda to the rescue</em> posts will be linked here:</p>

<ul>
<li>Lists to wrap failure (this post)</li>
<li><a href="/blog/2018/06/04/lambda-pure-functions">Pure Functions</a></li>
<li><a href="/blog/2018/06/27/lambda-recursion">Recursion</a></li>
<li>...</li>
</ul>
]]></content>
        </entry>
    </feed>