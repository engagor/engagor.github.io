<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[CX Social Dev Blog]]></title>
    <link href="/blog/categories/IDE.xml" rel="self"/>
    <link href="/"/>
    <updated>2017-05-17T09:59:01+00:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Vim As A PHP IDE - Testing]]></title>
            <link href="/blog/2017/05/15/vim-ide-testing"/>
            <updated>2017-05-15T10:00:00+00:00</updated>
            <id>/blog/2017/05/15/vim-ide-testing</id>
            <content type="html"><![CDATA[<p><strong>This blogpost is part of the "Vim As A PHP IDE" series, which starts <a href="/blog/2017/01/01/vim-ide-setting-up">here</a>.</strong></p>

<p>I used to always run my unit tests from the command line, but the integration that IDEs give is great. If something goes wrong you can immedately jump to where you need to be to fix it, and your test results remain visible in the same window you're working on. I wanted the same thing in Vim, so I started the investigation.</p>

<p>The first thing I did was to use the default Vim <code>:!</code> shell command mode for that (if you want to know more, check <code>:h :!</code>). I was using <a href="http://www.phpspec.net/">phpspec</a> at that time, so I created two hotkeys, one to describe a new class, and one to run the tests. In <code>.vimrc</code>:</p>

<pre><code class="vim">" PHP run phpspec
noremap &lt;Leader&gt;d :! bin/phpspec desc 
noremap &lt;Leader&gt;o :! bin/phpspec run&lt;CR&gt;
</code></pre>

<p>The problem with that approach, is that Vim doesn't know what to do with them, and just shows you the command line output they provide. I wanted more integration between my tools. After some more looking around, I found out that Vim has support to run a <code>compiler</code> command, and interpret its output with some kind of regex. You can run it using <code>:make</code> and if there are errors in the build, it collects them in a list which you can use to jump to the place you need to be to fix it. Sounds just like what I needed!</p>

<p>And yes, it turns out some other people also found that out. There's a <a href="https://github.com/afternoon/vim-phpunit">PHPUnit compiler</a>, which lets you use Vim's <code>:make</code> command with PHPUnit. Great! There also seems to be a <a href="https://github.com/renanivo/phpspec.vim">phpspec compiler</a>.</p>

<p>The cool thing is that Vim picks the right compiler for the right filetype, so you can do something similar for JavaScript files in your project, and have it all work fantastically with <code>:make</code>.</p>

<p>The last step for me was to create a hotkey in <code>.vimrc</code>, so that I can constantly run my unit tests with just one keystroke:</p>

<pre><code class="vim">noremap &lt;leader&gt;m :make&lt;CR&gt;
</code></pre>

<p>If your tests fail, <code>:make</code> fills up Vim's quickfix list with them. In <a href="/blog/2017/03/15/vim-ide-quality-control">episode 2</a>, I already showed you how to enable it to automatically open and close when it's filled or empty, respectively:</p>

<pre><code class="vim">" Automatically open &amp; close quickfix window
autocmd QuickFixCmdPost [^l]* nested cwindow
</code></pre>

<p><img src="/images/2017-05-15-vim-ide-testing/phpunit.png" alt="A test in PHPUnit failed" /></p>

<p>If you want to jump through the different errors without focussing on that list, you can just use <code>:cnext</code> and <code>:cprev</code>.</p>

<p>After some testing and trying out, it all seemed to work great for me. Fantastic, up to the next episode!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Vim As A PHP IDE - Git]]></title>
            <link href="/blog/2017/04/18/vim-ide-git"/>
            <updated>2017-04-18T10:00:00+00:00</updated>
            <id>/blog/2017/04/18/vim-ide-git</id>
            <content type="html"><![CDATA[<p><strong>This blogpost is part of the "Vim As A PHP IDE" series, which starts <a href="/blog/2017/01/01/vim-ide-setting-up">here</a>.</strong></p>

<p>As developers we use Git <strong>a lot</strong>. I mean the whole time.</p>

<blockquote>
  <p>Why did I do that?</p>
</blockquote>

<p>A.k.a <code>git blame</code></p>

<blockquote>
  <p>What am I doing?</p>
</blockquote>

<p>A.k.a. <code>git status</code></p>

<blockquote>
  <p>What did I change?</p>
</blockquote>

<p>A.k.a. <code>git diff</code></p>

<blockquote>
  <p>This is why I did this!</p>
</blockquote>

<p>A.k.a. <code>git commit</code></p>

<p>I wouldn't know how to work without git anymore, and it has also found its way into my "IDE" workflow, even though I used it "purely" from the cli for a long time. Let's see how to work with git from Vim. I'm assuming you have the git binary installed on your system.</p>

<h2 id="seeing-what-changed-in-the-current-file">Seeing what changed in the current file</h2>

<p>There's this neat little plugin called <a href="https://github.com/airblade/vim-gitgutter">GitGutter</a>, which just shows you the classic <code>+</code> and <code>-</code> signs next to added and deleted code in open files. As an added bonus, it lets you jump between changed blocks of code within a file, using the <code>:GitGutterNextHunk</code> and <code>:GitGutterPrevHunk</code> commands, which you can bind to a key in your <code>.vimrc</code>, e.g.:</p>

<pre><code class="vim">" Hop from gitgutter hunk to hunk
nmap &lt;Leader&gt;v :GitGutterNextHunk&lt;CR&gt;
nmap &lt;Leader&gt;b :GitGutterPrevHunk&lt;CR&gt;
</code></pre>

<p><img src="/images/2017-04-18-vim-ide-git/git-gutter.png" alt="Git Annotations In Gutter" /></p>

<h2 id="the-real-deal">The Real Deal</h2>

<p>Using git from Vim couldn't be more intuitive (and powerful) than with <a href="http://github.com/tpope/vim-fugitive">Fugitive</a>. I do everything from Vim now.</p>

<h3 id="why-did-i-do-that%3F-%60%3Agblame%60">Why did I do that? <code>:Gblame</code></h3>

<p>Using the Fugitive <code>:Gblame</code> command, you quickly annotate the current file with <code>git blame</code> information, which lets you jump through history. From the annotation, you can just press <code>Enter</code> and see the complete commit in which that line was changed. From that commit view, you can again use <code>Enter</code> to dive in the history of that file even further, until you found what you were looking for.</p>

<p><img src="/images/2017-04-18-vim-ide-git/git-blame.png" alt="Git Blame With Fugitive" /></p>

<h3 id="what-am-i-doing%3F-%60%3Agstatus%60">What am I doing? <code>:Gstatus</code></h3>

<p>The <code>:Gstatus</code> command opens a split window in Vim, which is an interactive wrapper around the output of <code>git status</code>. From there, you can jump between files in the list using <code>&lt;C-n&gt;</code> and <code>&lt;C-p&gt;</code>, press <code>Enter</code> to open the file under cursor, and use <code>-</code> to <code>git add</code> files or <code>git reset</code> them. You can also press <code>p</code> to <code>git add --patch</code> them and see what you're doing. When you're done, you can press <code>C</code> to commit.</p>

<p><img src="/images/2017-04-18-vim-ide-git/git-status.png" alt="Git Status With Fugitive" /></p>

<h3 id="the-rest-of-git">The rest of git</h3>

<ul>
<li>Fugitive has <strong>really</strong> extensive support for resolving merge conflicts and diffing files, using Vim's built-in diff view. Here's some <a href="http://vimcasts.org/episodes/fugitive-vim-resolving-merge-conflicts-with-vimdiff/">great info about how that works</a>.</li>
<li>There's the <strong>great</strong> <code>:Gbrowse</code>, which opens the current file on GitHub (or other configurable host), and you can even use a Vim Visual mode selection and use <code>:Gbrowse</code> to directly link to those lines on GitHub.</li>
<li>There's a proxy command called <code>:Git</code> which just proxies everything to the command line git. This means you can <code>:Git pull</code> and other commands, just like you used to.</li>
</ul>

<h2 id="hotkeys">Hotkeys</h2>

<p>I created some hotkeys in <code>.vimrc</code>:</p>

<pre><code class="vim">" Git leader hotkeys
nmap &lt;Leader&gt;gs :Gstatus&lt;CR&gt;
nmap &lt;Leader&gt;gc :Gcommit&lt;CR&gt;
nmap &lt;Leader&gt;gb :Gblame&lt;CR&gt;
</code></pre>

<h2 id="wrapping-up">Wrapping up</h2>

<p>That's it really, super easy integration of git. Of course you could e.g. also integrate your current branch into your Vim statusline. Just check Fugitive's documentation! I don't feel the need for that, as I <code>:Gstatus</code> practically the whole time, and as a result, I see which branch I'm on the whole time! See you in the next episode!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Vim As A PHP IDE - Quality Control]]></title>
            <link href="/blog/2017/03/15/vim-ide-quality-control"/>
            <updated>2017-03-15T09:00:00+00:00</updated>
            <id>/blog/2017/03/15/vim-ide-quality-control</id>
            <content type="html"><![CDATA[<p><strong>This blogpost is part of the "Vim As A PHP IDE" series, which starts <a href="/blog/2017/01/01/vim-ide-setting-up">here</a>.</strong></p>

<p>So it seems that people find it really handy that their IDEs tell them when things are going wrong, and I can't really disagree with that. So let's see how we can get pretty much the same thing in Vim, for PHP.</p>

<ul>
<li>I need to be warned of syntax errors.</li>
<li>I need to be warned of unused variables, methods, fields, etc.</li>
<li>Every language has their own rules for indenting and tabs vs. spaces, and maybe even every project.</li>
<li>What about coding standards like PSR-2?</li>
</ul>

<p>Basically I do two things here:</p>

<ol>
<li>I make sure that my editor is configured correctly for the language and the project, using a simple default configuration in my <code>.vimrc</code> which I overwrite on a project basis using <a href="http://editorconfig.org/">EditorConfig</a>.</li>
<li>I use some static analysis tools for the other parts.</li>
</ol>

<h2 id="1.-basic-setup">1. Basic setup</h2>

<h3 id="filetype-plugin">Filetype plugin</h3>

<p>Depending on your taste, you might want to update your PHP filetype plugin in Vim, with a more modern version, for instance if you'd like <code>@param</code> highlighted differently in your PHPDoc blocks. You can find a more up-to-date plugin <a href="https://github.com/StanAngeloff/php.vim">here</a>.</p>

<h3 id="editor-config">Editor Config</h3>

<p>To properly configure my editor, I use the simple snippet in my <code>~/.vim/ftplugin/php.vim</code> that I also posted in the first episode of this blog series:</p>

<pre><code class="vim">" Some basic PSR code style rules
set tabstop=4           " Tab width
set softtabstop=4       " Soft tab width
set shiftwidth=4        " Shift width
set expandtab           " Use spaces instead of tabs
</code></pre>

<p>I override this with project settings, using <a href="http://editorconfig.org/">EditorConfig</a>. It's as easy as installing the <a href="https://github.com/editorconfig/editorconfig-vim">EditorConfig plugin</a> for Vim.</p>

<p>In my projects I then have a <code>.editorconfig</code> file that might look like this:</p>

<pre><code class="editorconfig">; This file is for unifying the coding style for different editors and IDEs.
; More information at http://editorconfig.org

root = true

[**.{php,js,scss,html}]
charset = utf-8
indent_size = 4
indent_style = space
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true
</code></pre>

<h2 id="2.-static-analysis">2. Static Analysis</h2>

<p>On to more interesting stuff, for the rest of our list: syntax errors, coding guideline violations, unused variables, and the like. The cool part of this, is that many of these things are covered by great PHP tools:</p>

<ul>
<li>syntax errors: <code>php -l</code></li>
<li>coding guideline violations: <a href="https://pear.php.net/package/PHP_CodeSniffer/">PHP Code Sniffer</a></li>
<li>unused variables and other possible issues with code: <a href="https://phpmd.org/">PHP Mess Detector</a></li>
</ul>

<p>Even greater is that there's a great Vim plugin that combines all of these quality control tools into one great automated package: <a href="https://github.com/vim-syntastic/syntastic">Syntastic</a>, and it's fantastically easy to install. Use your Vim package manager, and put some lines into your <code>.vimrc</code> to configure it:</p>

<pre><code class="vim">" Syntastic configuration
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
</code></pre>

<p>Now to configure the PHP specific tools, that I mentioned above, I do it like this:</p>

<pre><code class="vim">" Syntastic configuration for PHP
let g:syntastic_php_checkers = ['php', 'phpcs', 'phpmd']
let g:syntastic_php_phpcs_exec = './bin/phpcs'
let g:syntastic_php_phpcs_args = '--standard=psr2'
let g:syntastic_php_phpmd_exec = './bin/phpmd'
let g:syntastic_php_phpmd_post_args = 'cleancode,codesize,controversial,design,unusedcode'
</code></pre>

<p>This works because the <code>phpcs</code> and <code>phpmd</code> binaries live in a <code>bin/</code> directory inside my project's directory (I installed them using composer). If you have global installs of these tools, you can just leave out these config lines, Syntastic knows where to find them. As we now have the <code>php -l</code> linter as a Syntastic checker, we can remove the <code>autocmd</code> from our <code>.vimrc</code>.</p>

<p>Some screenshots for the visually minded people:</p>

<p><img src="/images/2017-03-15-vim-ide-quality-control/syntax-error.png" alt="Syntax error detection with php -l" /></p>

<p><img src="/images/2017-03-15-vim-ide-quality-control/psr-violation.png" alt="PSR-2 violation" /></p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>Now I get live feedback about the quality of my code! Great! On to the next episode.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Vim As A PHP IDE - Exploring Code]]></title>
            <link href="/blog/2017/02/15/vim-ide-exploring-code"/>
            <updated>2017-02-15T09:30:00+00:00</updated>
            <id>/blog/2017/02/15/vim-ide-exploring-code</id>
            <content type="html"><![CDATA[<p><strong>This blogpost is part of the "Vim As A PHP IDE" series, which starts <a href="/blog/2017/01/01/vim-ide-setting-up">here</a>.</strong></p>

<p>As it turns out, finding things in a huge project is one of the main reasons people use an IDE. The most frequently used functionality seems to be</p>

<ul>
<li>searching for a file by its name;</li>
<li>searching within the current file;</li>
<li>searching for something arbitrary in the current project;</li>
<li>searching for methods or classes;</li>
<li>"jumping" to implementations of interfaces, child classes, definitions of methods;</li>
<li>finding usages of a method;</li>
</ul>

<h2 id="finding-files-by-their-names">Finding files by their names</h2>

<p>Finding files is something I'm very bad at. I mostly remember only part of the name, or nothing at all. That's why I want to search for files in a "fuzzy" way, if at all. For fuzzy file search, a feature found in most text editors and IDEs these days, I use <a href="https://github.com/kien/ctrlp.vim">CtrlP</a>, which does that just fine. It also has some nice extra commands that let you fuzzily find files in your open buffers, tags (more on that later), and bookmarks.</p>

<p>Some people like to use <a href="https://github.com/scrooloose/nerdtree">NerdTree</a> to have a nice directory listing to the left of the screen, like in Sublime Text or similar editors. You can use it, and I sometimes do for its <code>:NERDTreeFind</code> command, but for most of your needs, the default file browser in Vim is great. You can open it like you open any file, just open a directory instead e.g. <code>:e src/</code>.</p>

<h2 id="searching-within-the-current-file">Searching within the current file</h2>

<p>To find something in the current file, Vim provides a huge number of options. There's the default forward search command, <code>/</code>, which can be pimped a bit to behave in a more "natural" way. In <code>.vimrc</code>:</p>

<pre><code class="vim">set incsearch           " search as characters are entered
set hlsearch            " highlight matches
</code></pre>

<p>And you can search backwards in exactly the same way by using <code>?</code>. Jump to next and previous hits with <code>n</code> and <code>N</code>. And of course you can use regex.</p>

<p>Then there are some more "special" ways of searching in the current file:</p>

<ul>
<li>Hop to the next occurence of the word under cursor <code>*</code></li>
<li>Hop to the previous occurence of the word under cursor <code>#</code></li>
<li>Hop to the next method <code>]]</code></li>
<li>Hop to the previous method <code>[[</code></li>
<li>Hop to the definition of a variable under cursor <code>gd</code> (goto definition)</li>
</ul>

<h2 id="searching-for-arbitrary-text-in-the-current-project">Searching for arbitrary text in the current project</h2>

<p>I use <code>ag</code> as my main code search engine. It's a great command line tool to search codebases really fast. I use it on the command line, as well as in Vim, to replace <code>:vimgrep</code> with something faster. It's also the basis for some more interesting stuff, which I'll talk about later.</p>

<p>You'll need to have the <code>ag</code> binary for your operating system installed, using e.g. <code>brew install ag</code>. Check if it works by searching your codebase for a class, e.g. <code>ag HttpKernelInterface</code>.</p>

<p>Install the <code>Ack.vim</code> plugin, that you can find <a href="https://github.com/mileszs/ack.vim">here</a>. Then set the default search engine for the plugin to <code>ag</code> in your <code>.vimrc</code>:</p>

<pre><code class="vim">" Ack -&gt; Ag
if executable('ag')
    let g:ackprg = 'ag --vimgrep'
endif
</code></pre>

<p>Open Vim in your codebase's working directory and try it there, e.g. <code>:Ack HttpKernelInterface</code>. This should jump straight to the first match found.</p>

<p>The problem with this is that you don't have a visual representation of what else was found. Luckily, and much like <code>:vimgrep</code>, <code>:Ack</code> fills the quickfix list with matches, so you can use <code>:cwindow</code> to show matches (and see also <code>:cnext</code>, <code>:cprev</code>, <code>:cclose</code>). If you want your quicklist to open automatically if anything was found you can add this to your <code>.vimrc</code>:</p>

<pre><code class="vim">" Automatically open &amp; close quickfix window
autocmd QuickFixCmdPost [^l]* nested cwindow
</code></pre>

<h2 id="searching-for-methods-or-classes">Searching for methods or classes</h2>

<p>Now this is where it gets interesting, and where people somewhat underestimate Vim. Using an external application to generate an index of your project's "tags" (classes, interfaces, methods, variables, etc), which Vim can interpret, it provides jumping to all these things and back! This is great. How to set it up?</p>

<p>You'll need to have the <code>ctags</code> binary for your operating system installed, using e.g. <code>brew install ctags</code>. Check if it works by issueing this command <code>ctags --version</code>. I created a config file for it in my <code>$HOME</code> directory, called <code>.ctags</code> with this in it:</p>

<pre><code class="ctags">--recurse=yes
--tag-relative=yes
--exclude=.git
--exclude=composer.phar
--exclude=*.js
--exclude=*.vim
--langmap=php:.engine.inc.module.theme.install.php
--PHP-kinds=+cfi-vj
</code></pre>

<p>The line with <code>--PHP-kinds</code> tells <code>ctags</code> to index classes, functions, interfaces, but not variables or javascript functions. You can tune this to your likings.</p>

<p>If you now use <code>ctags</code> from the command line to generate the tags file for your project, using <code>ctags -R .</code>, a file that Vim can interpret, called <code>tags</code> will be created.</p>

<ul>
<li>You can now open Vim on a tag like so <code>vim -t HttpKernelInterface</code></li>
<li>Or search for that tag from within Vim <code>:tag HttpKernelInterface</code></li>
<li>Or jump to the tag under the cursor: <code>&lt;C-]&gt;</code> or <code>&lt;C-$&gt;</code> depending on keyboard layout</li>
<li>if you jumped to some tags and you want to jump back, use <code>&lt;C-t&gt;</code></li>
</ul>

<p>Of course there are <a href="https://github.com/ludovicchabant/vim-gutentags">plugins</a> to manage your <code>tags</code> files for you.</p>

<h2 id="finding-implementations-of-interfaces%2C-child-classes">Finding implementations of interfaces, child classes</h2>

<p>So this is where the aforementioned <code>Ack</code> magic comes in handy, as it's not default Vim functionality, and I didn't find a plugin to do these things either. I basically just created some functions that find PHP implementations of an interface, and PHP subclassses of a class. I just put them in my <code>.vimrc</code>, but I'm planning on creating a very simple plugin for them.</p>

<pre><code class="vim">" PHP Find Implementations
function! PhpImplementations(word)
    exe 'Ack "implements.*' . a:word . ' *($|{)"'
endfunction

" PHP Find Subclasses
function! PhpSubclasses(word)
    exe 'Ack "extends.*' . a:word . ' *($|{)"'
endfunction

noremap &lt;Leader&gt;fi :call PhpImplementations('&lt;cword&gt;')&lt;CR&gt;
noremap &lt;Leader&gt;fe :call PhpSubclasses('&lt;cword&gt;')&lt;CR&gt;
</code></pre>

<p>As you can see, I added mappings to execute them for the word under cursor (<code>&lt;cword&gt;</code>). These key mappings should probably be done inside the PHP <code>augroup</code> we created in the previous post.</p>

<h2 id="finding-usages-of-a-method">Finding usages of a method</h2>

<p>Pretty much in the same spirit of the Vim functions I wrote to find implementations of an interface, I also wrote such a function to find usages of a method, which I also just added to my <code>.vimrc</code>:</p>

<pre><code class="vim">" PHP Find Usage
function! PhpUsage(word)
    exe 'Ack "::' . a:word . '\(|&gt;' . a:word . '\("'
endfunction

noremap &lt;Leader&gt;fu :call PhpUsage('&lt;cword&gt;')&lt;CR&gt;
</code></pre>

<h2 id="wrapping-up">Wrapping up</h2>

<p>So that is basically how I move around in our codebase, from within Vim. It's not all perfect, but it works perfectly fine for me and I find what I need, when I need it. Up to the next episode!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Vim As A PHP IDE - Setting Up]]></title>
            <link href="/blog/2017/01/01/vim-ide-setting-up"/>
            <updated>2017-01-01T08:00:00+00:00</updated>
            <id>/blog/2017/01/01/vim-ide-setting-up</id>
            <content type="html"><![CDATA[<p>I always get a lot of critique and disbelief when I mention that I use Vim to do my daily work in our PHP codebase. Most people in PHP have become avid users of <a href="https://www.jetbrains.com/phpstorm/">PhpStorm</a>, a great PHP IDE made by JetBrains. I'm unsure about my own reasons to use Vim over PhpStorm but I guess these are some factors:</p>

<ul>
<li>I do not only write PHP</li>
<li>I love the fact that using Vim is like speaking a language</li>
<li>I live in my terminal</li>
</ul>

<p>I'm hereby starting a blog series about how I use Vim as my IDE of choice for PHP development. This is not a Vim tutorial, I'm assuming that you can look up the basics <a href="http://vimcasts.org/">anywhere else</a> and that you know about <code>:h :h</code>. However, I'll show you how I manage to do my work in Vim, how you can accomplish the same thing, and that I don't have a lot of missing features compared to users of other IDEs. This will be a blog series, and I'll list up episodes below as they come out. Let's start with setting up for a really basic PHP oriented workflow.</p>

<h2 id="basic-%60.vimrc%60-setup">Basic <code>.vimrc</code> setup</h2>

<p>First of all, never put things in your <code>.vimrc</code> that you don't understand. There's a huge amount of documentation in Vim's built-in help pages, which you can access like this: <code>:h &lt;keyword&gt;</code>. These are some simple things that I put in my <code>.vimrc</code> that I want at all times:</p>

<pre><code class="vim">filetype plugin indent on " use the file type plugins
syntax on                 " Syntax highlighting
set number nu             " Line numbers
set cursorline            " Color the cursorline
set autoindent            " Auto indenting
set smartindent           " Smart indenting
</code></pre>

<h2 id="basic-packages-i-use-all-the-time">Basic Packages I Use All The Time</h2>

<h3 id="package-manager">Package Manager</h3>

<p>To be able to easily install Vim plugins, I use <a href="https://github.com/tpope/vim-pathogen">Pathogen</a> or another Vim package manager, they make it so much easier to install the other packages.</p>

<h3 id="multiple-cursors">Multiple Cursors</h3>

<p>Even though it's really not Vim-like to use this, sometimes it comes in handy to have multiple cursors, even though we all know it can be done using find-and-replace or using Vim's macros. There are multiple packages for this, I use <a href="https://github.com/terryma/vim-multiple-cursors">this one</a>.</p>

<h3 id="surroundings">Surroundings</h3>

<p>Adding, removing and editing brackets around all Vim objects like "words", "paragraphs", "HTML-tags", etc has been made super easy with <a href="https://github.com/tpope/vim-surround">surround.vim</a>, which makes all these actions feel like they were in Vim all along.</p>

<h3 id="sessions">Sessions</h3>

<p>To manage my sessions, I usually don't use any plugins, since Vim has basic session management built in. You can save your current session using <code>:mksession! &lt;name&gt;</code>. Vim will save a file with the <code>&lt;name&gt;</code> you specified. If you then close vim, you can come back to the same session by starting vim like this: <code>vim -S &lt;name&gt;</code>.</p>

<p>If you go with the aforementionned approach, your sessions won't be saved automatically. If you want to get more out of your sessions, you might want to try the <a href="https://github.com/tpope/vim-obsession">vim obsession</a> plugin.</p>

<h3 id="snippets">Snippets</h3>

<p>As a last general purpose plugin, I'll recommend some snippet managers. I myself don't use any of them, just because I started out with a very basic Vim setup and I didn't yet feel the need for one of them. But if you'd like one, check out <a href="https://github.com/sirver/UltiSnips">UltiSnips</a> or <a href="https://github.com/msanders/snipmate.vim">SnipMate</a>.</p>

<h2 id="php-specific-things-for-your-%60.vimrc%60">PHP Specific things for your <code>.vimrc</code></h2>

<p>Let's start looking at some PHP specific configurations. I created a specific <code>augroup</code> section in my <code>.vimrc</code>, to be able to define <code>autocmd</code>s that can be overwritten if I reload my <code>.vimrc</code>. I'll reference this <code>augroup</code> in the following episodes of this series, too. Let's use it to run the <code>php -l</code> linter after we save a PHP file. Here we go:</p>

<pre><code class="vim">augroup PHP
  autocmd! " Clear all autocmd's in this group before running them again

  " Check for PHP syntax errors after saving a file
  autocmd BufWritePost {*.php} echom system("php -l ".expand('%'))

augroup END
</code></pre>

<p>Let's set some basic configuration for all PHP files that we'll open. Create a file called <code>~/.vim/ftplugin/php.vim</code> and put this in it:</p>

<pre><code class="vim">" Some basic PSR code style rules
set tabstop=4           " Tab width
set softtabstop=4       " Soft tab width
set shiftwidth=4        " Shift width
set expandtab           " Use spaces instead of tabs
</code></pre>

<h2 id="what%27s-next%3F">What's next?</h2>

<p>When I talk to people about their IDE of choice, which I don't do often, these are some topics which seem to be important:</p>

<ul>
<li><a href="/blog/2017/02/15/vim-ide-exploring-code">exploring the codebase</a></li>
<li><a href="/blog/2017/03/15/vim-ide-quality-control">quality control</a></li>
<li><a href="/blog/2017/04/18/vim-ide-git">git integration</a></li>
<li><a href="/blog/2017/05/15/vim-ide-testing">testing integration</a></li>
<li>refactoring</li>
</ul>

<p>In the upcoming posts, I'll talk about those in more detail!</p>
]]></content>
        </entry>
    </feed>