<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[CX Social Dev Blog]]></title>
    <link href="/blog/categories/PHP.xml" rel="self"/>
    <link href="/"/>
    <updated>2017-12-22T13:17:37+00:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Parse Your Way Through Errors]]></title>
            <link href="/blog/2017/12/01/parse-your-way-through-errors"/>
            <updated>2017-12-01T10:00:00+00:00</updated>
            <id>/blog/2017/12/01/parse-your-way-through-errors</id>
            <content type="html"><![CDATA[<p>In our code base there's a static function to log an error:</p>

<pre><code class="php">final class Debug
{
    public static function error(
        $msg,
        $obj = false,
        $category = 'user',
        $type = 'user'
    ) {
        // ...
    }
}
</code></pre>

<pre><code class="php">Debug::error('API call failed', $response, 'facebook', 'api-call-failed');
</code></pre>

<p>The first argument is a message, the second argument can be a value of any type, the third and fourth argument are used for grouping errors by category and type. This is very useful for analytics.</p>

<p>Ignore for a second that we should use the <a href="http://www.php-fig.org/psr/psr-3/">PSR-3: Logger Interface</a>. We could easily move this <code>Debug</code> class behind an implementation of that interface if we ever wanted to.</p>

<h2 id="the-problem">The problem</h2>

<p>Did you notice that the category and type have a default value <code>"user"</code>? I don't know when or why this was introduced in our code base but it's bad. When the category and type is not set the errors will get lost in the category <code>"user"</code> and the type <code>"user"</code>.</p>

<p>How can we find these <code>Debug::error</code> statements without a category and a type? We don't want to ignore these errors.</p>

<h2 id="use-a-regex%3F">Use a regex?</h2>

<p>Maybe... If the arguments are simple:</p>

<p><img src="/images/2017-12-01-parse-your-way-through-errors/regex.png" alt="RegExr experiment to find Debug::error's" /></p>

<p>(<a href="http://regexr.com/3h8th">RegExr</a>)</p>

<p>Note that this is the first regex that came to my mind. We could improve that regex but let's not waste our time. We need a better way. We need something that truly understands our code.</p>

<h2 id="nikita%27s-php-parser-to-the-rescue">Nikita's PHP Parser to the rescue</h2>

<blockquote>
  <p>A parser is useful for <a href="http://en.wikipedia.org/wiki/Static_program_analysis">static analysis</a>, manipulation of code and basically any other application dealing with code programmatically. A parser constructs an <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> (AST) of the code and thus allows dealing with it in an abstract and robust way.</p>
  
  <p><a href="https://github.com/nikic/PHP-Parser/blob/master/doc/0_Introduction.markdown">https://github.com/nikic/PHP-Parser</a></p>
</blockquote>

<p>Parsing a programming language is hard. This package makes it easy!</p>

<p>Let's see how we can use the package to find <code>Debug::error</code>'s without a category and type.</p>

<ul>
<li><code>$ mkdir parser-demo</code></li>
<li><code>$ cd parser-demo</code></li>
<li><code>$ composer require nikic/php-parser</code></li>
</ul>

<p>This package is bundled with a binary (<code>php-parse</code>) to play with the parser:</p>

<pre><code class="sh">$ vendor/bin/php-parse '&lt;?php Debug::error("message", $var);'
====&gt; Code &lt;?php Debug::error("message", $var);
==&gt; Node dump:
array(
    0: Expr_StaticCall(
        class: Name(
            parts: array(
                0: Debug
            )
        )
        name: error
        args: array(
            0: Arg(
                value: Scalar_String(
                    value: message
                )
                byRef: false
                unpack: false
            )
            1: Arg(
                value: Expr_Variable(
                    name: var
                )
                byRef: false
                unpack: false
            )
        )
    )
)
</code></pre>

<p>The abstract syntax tree is a list of statements. The first statement is an <a href="https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/Node/Expr/StaticCall.php"><code>Expr_StaticCall</code></a>. A static call has a <code>class</code>, <code>name</code> and <code>args</code>. If the count of <code>args</code> is not equal to 4 we know that the category and/or type is missing. Let's translate that in some code:</p>

<p><code>$ touch find.php</code></p>

<p>First, we'll need a way to find all PHP files in our code base:</p>

<pre><code class="php">&lt;?php

$directory = $argv[1];
$directoryIterator = new RecursiveDirectoryIterator($directory);
$directoryIterator = new RecursiveIteratorIterator($directoryIterator);
$files = new RegexIterator($directoryIterator, '/^.+\.php$/i', RecursiveRegexIterator::GET_MATCH);
</code></pre>

<p>We can now pass a path to our code base as a command line argument:</p>

<p><code>$ php find.php ~/path/to/code</code></p>

<p>Secondly, we'll need a way to traverse all nodes of an AST. Meet the <a href="https://github.com/nikic/PHP-Parser/blob/master/doc/2_Usage_of_basic_components.markdown#node-traversation"><code>NodeTraverser</code></a>.</p>

<pre><code class="php">&lt;?php

use PhpParser\Error;
use PhpParser\NodeTraverser;
use PhpParser\ParserFactory;
use PhpParser\NodeVisitor\NameResolver;

require_once __DIR__ . '/vendor/autoload.php';

// ... directory iterator

$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);

foreach ($files as $file) {
    try {
        $code = file_get_contents($file[0]);
        $statements = $parser-&gt;parse($code);
        $traverser = new NodeTraverser;
        $traverser-&gt;addVisitor(new NameResolver);
        $traverser-&gt;addVisitor(new DebugErrorVisitor($file[0]));
        $traverser-&gt;traverse($statements);
    } catch (Error $e) {
        echo 'Parse Error: ', $e-&gt;getMessage(), PHP_EOL;
    }
}
</code></pre>

<p>The <code>NodeTraverser</code> will call a method (<code>enterNode</code>) on each visitor for each node in the AST. Let's implement <code>DebugErrorVisitor</code>:</p>

<pre><code class="php">&lt;?php

use PhpParser\Node;
use PhpParser\NodeVisitorAbstract;
use PhpParser\Node\Expr\StaticCall;

require_once __DIR__ . '/vendor/autoload.php';

final class DebugErrorVisitor extends NodeVisitorAbstract
{
    private $file;

    public function __construct($file)
    {
        $this-&gt;file = $file;
    }

    public function enterNode(Node $node)
    {
        if (!$node instanceof StaticCall) {
            return;
        }

        if ($node-&gt;class instanceof Name &amp;&amp; $node-&gt;class-&gt;toString !== 'Debug') {
            return;
        } elseif ($node-&gt;class !== 'Debug') {
            return;
        }

        if ($node-&gt;name !== 'error') {
            return;
        }

        if (count($node-&gt;args) !== 4) {
            echo "Found {$node-&gt;class}::{$node-&gt;name} in {$this-&gt;file} on line {$node-&gt;getLine()}", PHP_EOL;
        }
    }
}

// ... directory iterator
</code></pre>

<ol>
<li>If <code>$node</code> is not a <code>StaticCall</code> we'll return.</li>
<li>If the class name is not <code>Debug</code> we'll return (The class will be a <code>Name</code> instance if it's in a namespace).</li>
<li>If the name of the method we're calling is not <code>error</code> we'll return.</li>
<li>If the count of arguments is not 4, we found an <code>Debug::error</code> we're interested in.</li>
</ol>

<p>Let's put it all together:</p>

<pre><code class="php">&lt;?php

use PhpParser\Node;
use PhpParser\NodeVisitorAbstract;
use PhpParser\Node\Expr\StaticCall;
use PhpParser\Error;
use PhpParser\NodeTraverser;
use PhpParser\ParserFactory;
use PhpParser\NodeVisitor\NameResolver;

require_once __DIR__ . '/vendor/autoload.php';

final class DebugErrorVisitor extends NodeVisitorAbstract
{
    private $file;

    public function __construct($file)
    {
        $this-&gt;file = $file;
    }

    public function enterNode(Node $node)
    {
        if (!$node instanceof StaticCall) {
            return;
        }

        if ($node-&gt;class instanceof Name &amp;&amp; $node-&gt;class-&gt;toString !== 'Debug') {
            return;
        } elseif ($node-&gt;class !== 'Debug') {
            return;
        }

        if ($node-&gt;name !== 'error') {
            return;
        }

        if (count($node-&gt;args) !== 4) {
            echo "Found {$node-&gt;class}::{$node-&gt;name} in {$this-&gt;file} on line {$node-&gt;getLine()}", PHP_EOL;
        }
    }
}

$directory = $argv[1];
$directoryIterator = new RecursiveDirectoryIterator($directory);
$directoryIterator = new RecursiveIteratorIterator($directoryIterator);
$files = new RegexIterator($directoryIterator, '/^.+\.php$/i', RecursiveRegexIterator::GET_MATCH);

$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);

foreach ($files as $file) {
    try {
        $code = file_get_contents($file[0]);
        $statements = $parser-&gt;parse($code);
        $traverser = new NodeTraverser;
        $traverser-&gt;addVisitor(new NameResolver);
        $traverser-&gt;addVisitor(new DebugErrorVisitor($file[0]));
        $traverser-&gt;traverse($statements);
    } catch (Error $e) {
        echo 'Parse Error: ', $e-&gt;getMessage(), PHP_EOL;
    }
}
</code></pre>

<p>We can now call the script with a path to our code base and it will find <code>Debug::error</code>'s without a category and a type accurately. Perhaps we can use this script in our Jenkins setup to let a build fail if there's a <code>Debug::error</code> without a category and type.</p>

<p>We could take this one step further and ask for a category and type on the command line (using <code>readline</code>) and replace it automatically but I'll leave that as an exercise for the reader. üòè</p>

<p>Happy programming!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Refactoring to Collections]]></title>
            <link href="/blog/2017/11/15/refactoring-to-collections"/>
            <updated>2017-11-15T10:00:00+00:00</updated>
            <id>/blog/2017/11/15/refactoring-to-collections</id>
            <content type="html"><![CDATA[<p>How many times have you seen code like this?</p>

<pre><code class="php">public function displayCoffeeRunsOpenForOrders()
{
    $coffeeRuns = $this-&gt;coffeeRunsRepository-&gt;getAll();
    $openForOrders = array();

    foreach ($coffeeRuns as $coffeeRun) {
        if ($coffeeRun-&gt;ordersCanBeMade()) {
            $openForOrders[] = $coffeeRun;
        }
    }

    return $openForOrders;
}
</code></pre>

<p>Our office is very close to a <a href="http://simon-says.be/">great coffee bar</a>, and people are going there from time to time to get coffee for everyone in the office. Keeping track of who's going for coffee and who wants which coffee can be daunting, which is why I'm making this app. Let's take a closer look at that piece of code.</p>

<p>We're manually traversing an array of <code>CoffeeRun</code> objects that we got out of the Repository to filter out those who are open for orders. If we find one, we add it to a new array. This way we build a list of <code>CoffeeRuns</code> that are still accepting orders.</p>

<h2 id="to-iterator-or-not%2C-that%27s-the-question">To Iterator or not, that's the question</h2>

<p>Now, there's nothing very wrong with this, but it could be made a whole lot better, I think. Let's say that the Repository contains 1000 <code>CoffeeRun</code>s. We're now forcing the Repository to return an array of 1000 <code>CoffeeRun</code> objects when we call <code>getAll()</code>. That's not great. But let's think about it... The Repository already represents a list of all <code>CoffeeRun</code> objects. Why can't we just iterate over it? Something like this:</p>

<pre><code class="php">public function displayCoffeeRunsOpenForOrders()
{
    $coffeeRuns = $this-&gt;coffeeRunsRepository;
    $openForOrders = array();

    foreach ($coffeeRuns as $coffeeRun) {
        if ($coffeeRun-&gt;ordersCanBeMade()) {
            $openForOrders[] = $coffeeRun;
        }
    }

    return $openForOrders;
}
</code></pre>

<p>Having a repository we can iterate over like that would already be a first step. We could implement the <code>Iterator</code> interface within the Repository, and have this functionality immediately. But that would leave the foreach out there, and that would also present a problem for our dependency injection: the class where this <code>displayCoffeeRunsOpenForOrders</code> is a controller, and it has the Repository injected in its constructor, like this:</p>

<pre><code class="php">public function __construct(CoffeeRunsRepository $repository)
{
    $this-&gt;coffeeRunsRepository = $repository;
}
</code></pre>

<p>If we'd count on the fact that the Repository is now an <code>Iterator</code>, we should either typehint on it, but then we lose our typehint for <code>CoffeeRunsRepository</code>, which we don't want. Or we could make the <code>CoffeeRunsRepository</code> interface extend the <code>Iterator</code> interface, but then we get a really big interface we need to implement for every implementation of the Repository. Both of which are annoying to say the least.</p>

<h2 id="think-solidly-different">Think SOLIDly Different</h2>

<p>Let's try something completely different. In fact, the <code>foreach</code> in that method, is blocking progress for us right now; Let's extract that whole block to a method. This is what was in the controller before the extraction:</p>

<pre><code class="php">public function displayCoffeeRunsOpenForOrders()
{
    $coffeeRuns = $this-&gt;coffeeRunsRepository-&gt;getAll();
    $openForOrders = array();

    foreach ($coffeeRuns as $coffeeRun) {
        if ($coffeeRun-&gt;ordersCanBeMade()) {
            $openForOrders[] = $coffeeRun;
        }
    }

    return $openForOrders;
}
</code></pre>

<p>In the Repository we added a new method <code>openForOrders()</code>, and we kept the same implementation as before, which now resides in the implementation of that method:</p>

<pre><code class="php">interface CoffeeRunsRepository
{
    // ...

    /**
     * @return CoffeeRun[] A list of CoffeeRuns open for orders
     */
    public function openForOrders();

    // ...
}
</code></pre>

<pre><code class="php">final class CoffeeRunsRepositoryInMemory implements CoffeeRunsRepository
{
    // ...

    public function openForOrders()
    {
        $coffeeRuns = $this-&gt;getAll();
        $openForOrders = array();

        foreach ($coffeeRuns as $coffeeRun) {
            if ($coffeeRun-&gt;ordersCanBeMade()) {
                $openForOrders[] = $coffeeRun;
            }
        }

        return $openForOrders;
    }

    // ...
}
</code></pre>

<p>This is what's left in the controller after extraction:</p>

<pre><code class="php">public function displayCoffeeRunsOpenForOrders()
{
    return $this-&gt;coffeeRunsRepository-&gt;openForOrders();
}
</code></pre>

<p>I don't like the <code>Repository</code> word in there, while we're thinking about the Repository as just being a Collection. Let's rename the variable in our controller. Notice how well this reads:</p>

<pre><code class="php">public function displayCoffeeRunsOpenForOrders()
{
    return $this-&gt;coffeeruns-&gt;openForOrders();
}
</code></pre>

<p>"Return CoffeeRuns that are Open For Orders". I like it. What's even better, is that the filtering of the Collection is now happening in the object that worries about the Collection, namely the Repository. This means that the specific implementations can optimize for their own benifits. E.g. the database implementation of the Repository can use a specific <code>WHERE</code> query so that it doesn't need to filter <code>CoffeeRun</code>s in PHP, and as a result of that it doesn't need to load a whole list of <code>CoffeeRun</code> objects into memory.</p>

<h2 id="bump-your-head-twice">Bump your head twice</h2>

<p>What if we want a second method in our controller that displays all CoffeeRuns that are open for orders, and will happen before noon? The <code>openForOrders()</code> method won't be enough. We could use it, and then use a <code>foreach</code> as in the first example of the blog post, but then we're back to square one. We could also make it a Repository method, and that would be okay, but only if we don't have to do it too many times. Let's look for a different solution.</p>

<p>It looks like we now have two problems:</p>

<ol>
<li>We want to encapsulate the "looping over a list and picking out specific items"</li>
<li>We want to combine several of these actions on a list, or at least do them in succession</li>
</ol>

<p>The problems always come up when we're talking to the Repository. We made two changes to it, that were both half solutions. The Repository has too many responsibilities (Storage and Collection). What would happen if we'd return an object representing a list of CoffeeRun objects from the Repository, and use that to iterate over? The Repository only takes care of the storage, and the Collection object takes care of the Collection stuff.</p>

<p>What we want to do is "filter" CoffeeRuns so that we get CoffeeRuns that are open for orders, and then filter those again so that we get those open for orders that are happening before noon. In pseudo code:</p>

<pre><code class="php">coffeeRuns = repository.getAll
coffeeRuns
    .thatAre(openForOrders)
    .thatAre(happeningBeforeNoon)
</code></pre>

<p>If we can express <code>openForOrders</code> and <code>happeningBeforeNoon</code> as functions that take a <code>CoffeeRun</code> object and return a boolean (we'll call them predicates), then the <code>thatAre()</code> implementation could be very generic! Let's check it out:</p>

<pre><code class="php">$openForOrders = function (CoffeeRun $coffeeRun)
{
    return $coffeeRun-&gt;ordersCanBeMade();
};

$noon = new DateTime('today noon');
$happeningBeforeNoon = function (CoffeeRun $coffeeRun) use ($noon)
{
    return $coffeeRun-&gt;getDate() &lt; $noon;
};
</code></pre>

<p>Now we'll create the <code>CoffeeRuns</code> Collection object, with a <code>thatAre</code> method:</p>

<pre><code class="php">interface CoffeeRuns
{
    /**
     * @param callable function that takes a CoffeeRun and returns a boolean
     *
     * @return CoffeeRuns that match the predicate
     */
    public function thatAre(callable $matchingPredicate);

    /**
     * @return CoffeeRun[] An array of CoffeeRuns
     */
    public function asArray();
}
</code></pre>

<p>Let's create a na√Øve <code>array</code> based implementation of it:</p>

<pre><code class="php">final class CoffeeRunsArray implements CoffeeRuns
{
    private $coffeeRuns;

    public function __construct(array $coffeeRuns)
    {
        $this-&gt;coffeeRuns = $coffeeRuns;
    }

    public function thatAre(callable $matchingPredicate)
    {
        return new static(
            array_filter(
                $this-&gt;coffeeRuns,
                $matchingPredicate
            )
        );
    }

    public function asArray()
    {
        $this-&gt;coffeeRuns;
    }
}
</code></pre>

<p>Right now, we can have our <code>CoffeeRunsRepository</code> return a <code>CoffeeRuns</code> Collection object for the <code>getAll()</code> method instead of <code>CoffeeRun[]</code> (an array of CoffeeRun) objects, and remove the specific methods we created, like <code>openForOrders()</code>.</p>

<pre><code class="php">interface CoffeeRunsRepository
{
    /**
     * @return CoffeeRuns A collection of CoffeeRuns
     */
    public function getAll();
}
</code></pre>

<p>In the controller, we now get this:</p>

<pre><code class="php">final class CoffeeController
{
    private $coffeeRuns;
    private $openForOrders;
    private $happeningBeforeNoon;

    public function __construct(CoffeeRunsRepository $repository)
    {
        $this-&gt;coffeeRuns = $repository;

        $this-&gt;openForOrders = function (CoffeeRun $coffeeRun)
        {
            return $coffeeRun-&gt;ordersCanBeMade();
        };

        $noon = new DateTime('today noon');
        $this-&gt;happeningBeforeNoon = function (CoffeeRun $coffeeRun) use ($noon)
        {
            return $coffeeRun-&gt;getDate() &lt; $noon;
        };
    }

    public function displayCoffeeRunsOpenForOrders()
    {
        $coffeeRuns =
            $this-&gt;coffeeRuns-&gt;getAll()
            -&gt;thatAre($this-&gt;openForOrders);

        return $coffeeRuns-&gt;asArray();
    }

    public function displayCoffeeRunsOpenForOrdersAndBeforeNoon()
    {
        $coffeeRuns =
            $this-&gt;coffeeRuns-&gt;getAll()
            -&gt;thatAre($this-&gt;openForOrders)
            -&gt;thatAre($this-&gt;happeningBeforeNoon);

        return $coffeeRuns-&gt;asArray();
    }
}
</code></pre>

<p>As you can see, the individual methods got very readable. The operations on the Collections are encapsulated. I extracted the <code>$openForOrders</code> and <code>$happeningBeforeNoon</code> predicates to class variables, because I didn't like the duplication in both controller methods, however, I'm not satisfied with their presence in the constructor. We could create a <code>Predicate</code> interface and make the <code>thatAre()</code> method accept <code>Predicate</code> instances. As a result our controller would just do something like <code>$coffeeRuns-&gt;thatAre(new OpenForOrders());</code>. But let's leave it like this for now. I've got some critical questions coming in:</p>

<h2 id="wait-a-minute%21-you-didn%27t-solve-the-memory-problem%21">Wait a minute! You didn't solve the memory problem!</h2>

<p>Exactly. Let's do that right now.</p>

<pre><code class="php">final class CoffeeRunsWithIterator implements CoffeeRuns
{
    private $coffeeRuns;
    private $predicates;

    public function __construct(Iterator $coffeeRuns, array $predicates = array())
    {
        $this-&gt;coffeeRuns = $coffeeRuns;
        $this-&gt;predicates = $predicates;
    }

    public function thatAre(callable $matchingPredicate)
    {
        $predicates = $this-&gt;predicates;
        $predicates[] = $matchingPredicate;

        return new static(
            $this-&gt;coffeeRuns,
            $predicates
        );
    }

    public function asArray()
    {
        $collectionAsArray = array();

        foreach ($this-&gt;coffeeRuns as $coffeeRun) {
            foreach ($this-&gt;predicates as $predicate) {
                if (call_user_func($predicate, $coffeeRun) !== true) {
                    continue 2;
                }
            }

            $collectionAsArray[] = $coffeeRun;
        }

        return $collectionAsArray;
    }
}
</code></pre>

<p>This is an implementation of the <code>CoffeeRuns</code> Collection interface that takes an <code>Iterator</code>. Whenever the <code>thatAre()</code> method gets called with a predicate, we don't do anything, except for creating a new instance of the Collection class with the same <code>Iterator</code> in it, but with the predicate added to the list of predicates that must be matched for each element in the Collection. It's only at the last step, when we try to extract the contents of the collection, that we run the <code>Iterator</code> and check every value against the given predicates. We still need to run the predicates against the whole collection, but because they are within an <code>Iterator</code>, the <code>Iterator</code> can e.g. get them from the database one by one. That's an implementation detail of the Repository.</p>

<h2 id="what-if-we-want-to-be-able-to-use-mysql-%60where%60-statements-in-our-repositories%3F">What if we want to be able to use MySQL <code>WHERE</code> statements in our Repositories?</h2>

<p>Let's say that we want to create a MySQL implementation of the Repository. We don't really want to write a query that will get the whole list of CoffeeRuns, even though we worked with an <code>Iterator</code> before (and thus preserving memory issues), so just passing closures to the <code>thatAre()</code> method will not help us a whole lot to write efficient queries. To improve on that, we could start passing our predicates as objects instead of closures, like this:</p>

<pre><code class="php">interface CoffeeRuns
{
    /**
     * @param Predicate that CoffeeRuns need to satisfy
     *
     * @return CoffeeRuns that match the predicate
     */
    public function thatAre(Predicate $matching);

    /**
     * @return CoffeeRun[] An array of CoffeeRuns
     */
    public function asArray();
}
</code></pre>

<p>A predicate could look something like this:</p>

<pre><code class="php">interface Predicate
{
    /**
     * @param CoffeeRun the CoffeeRun we want to check
     *
     * @return bool if the Predicate is satisfied by given CoffeeRun
     */
    public function isSatisfiedBy(CoffeeRun $coffeeRun);
}
</code></pre>

<p>And to get the same functionality as before we can implement it like this:</p>

<pre><code class="php">final class OpenForOrders implements Predicate
{
    public function isSatisfiedBy(CoffeeRun $coffeeRun)
    {
        return $coffeeRun-&gt;ordersCanBeMade();
    }
}
</code></pre>

<p>When we have this in place, implementing a repository that can translate these predicates to the correct <code>WHERE</code> statements is pretty much trivial: without doing an actual query, the Repository returns a <code>CoffeeRuns</code> collection object that can be filtered using <code>Predicate</code>s and when that is done, the query can be built by translating the Predicates to the appropriate <code>WHERE</code> statements. Now the <code>Predicate</code> object can still be used to check if a given <code>CoffeeRun</code> satisfies the rule encapsulated within it, but within the Repository, a more efficient way is used against the whole database table full of CoffeeRuns. Eric Evans calls this concept <code>Specification</code>, and you can read all about it in his great book <a href="http://dddcommunity.org/book/evans_2003/">Domain Driven Design</a>.</p>

<h2 id="doing-something-with-all-objects-in-our-collection">Doing something with all objects in our collection</h2>

<p>Let's say we want people to <code>stopOrdering()</code> for all <code>CoffeeRun</code>s that are happening before noon.</p>

<pre><code class="php">$stopOrdering = function (CoffeeRun $coffeeRun)
{
    $coffeeRun-&gt;stopOrdering();

    return $coffeeRun;
};

$coffeeRuns = $repository-&gt;getAll();
$stoppedOrderingForTheseRuns = $coffeeRuns
    -&gt;thatAre($happeningBeforeNoon)
    -&gt;updateEach($stopOrdering);
</code></pre>

<p>Let's add it to the Collection interface:</p>

<pre><code class="php">interface CoffeeRuns
{
    /**
     * @param Predicate that CoffeeRuns need to satisfy
     *
     * @return CoffeeRuns that match the predicate
     */
    public function thatAre(Predicate $matching);

    /**
     * @param callable function that takes a CoffeeRun and returns an updated one
     *
     * @return CoffeeRuns that got updated
     */
    public function updateEach(callable $update);

    /**
     * @return CoffeeRun[] An array of CoffeeRuns
     */
    public function asArray();
}
</code></pre>

<p>The implementation for the <code>CoffeeRunsArray</code> could be something like this:</p>

<pre><code class="php">final class CoffeeRunsArray implements CoffeeRuns
{
    private $coffeeRuns;

    public function __construct(array $coffeeRuns)
    {
        $this-&gt;coffeeRuns = $coffeeRuns;
    }

    public function thatAre(Predicate $predicate)
    {
        return new static(
            array_filter(
                $this-&gt;coffeeRuns,
                function (CoffeeRun $run) use ($predicate) {
                    return $predicate-&gt;isSatisfiedBy($run);
                }
            )
        );
    }

    public function updateEach(callable $update)
    {
        return new static(
            array_map(
                $update,
                $this-&gt;coffeeRuns
            )
        );
    }

    public function asArray()
    {
        $this-&gt;coffeeRuns;
    }
}
</code></pre>

<p>As you can see, the implementation is trivial in this case, but again it provides us with a powerful abstraction. The code that operates on the Collection doesn't have to know anything about how the Collection is implemented, it just knows about the methods we provided for interacting with it. For those that are into functional programming, we just implemented <code>filter</code> and <code>map</code> here.</p>

<p>I hope you see the value in this. For pieces of code where a lot of actions need to happen on Collections of objects, this might be the way to go. Since the code doesn't have to know anything about the implementation of the Collection, you can change it at any time. For instance, when you start out, you can just use a simple <code>Array</code> implementation, and swap it out for an <code>Iterator</code> later on when you notice memory consumption going up. It can also make things pretty readable, as demonstrated above with the <code>$coffeeRuns-&gt;thatAre(new OpenForOrders());</code>.</p>

<p>You can also choose to go A LOT further, or less far into this, as you desire. Good luck on your explorations!</p>

<p>PS: I gave a talk on this subject at the <a href="http://php.gent/">PHP.GENT meetup</a>, you can find the slides <a href="https://speakerdeck.com/turanct/the-language-of-collections">here</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Using decorators for debugging]]></title>
            <link href="/blog/2017/09/22/using-decorators-for-debugging"/>
            <updated>2017-09-22T10:00:00+00:00</updated>
            <id>/blog/2017/09/22/using-decorators-for-debugging</id>
            <content type="html"><![CDATA[<p>When you're writing SOLID code, you probably hide some implementation details behind interfaces in many parts of your codebase. In this post, we'll talk about an HTTP client, which is hidden behind an interface. The exact implementation we use doesn't matter. It could be a simple cURL call, or we could be using a more advance package like <a href="https://github.com/guzzle/guzzle/">Guzzle</a> or <a href="https://github.com/kriswallsmith/Buzz">Buzz</a>. In any case, our application knows only about the <code>HttpClient</code> interface that it defined, like this.</p>

<pre><code class="php">&lt;?php

namespace CoffeeRun;

interface HttpClient
{
    /**
     * @param Request $request An HTTP Request
     *
     * @throws ClientException if the request failed
     *
     * @return Response a response instance
     */
    public function execute(Request $request): Response;
}
</code></pre>

<p>Our code will ask the <code>HttpClient</code> implementation to <code>execute()</code> a <code>Request</code> and expects a <code>Response</code> if the call succeeded, or a <code>ClientException</code> if something unexpected happens.</p>

<p>The cool thing about this, is that our whole codebase needs to only know about this one interface, and not about the specific package that we're going to use. Plus, we can use another (fake) implementation of the <code>HttpClient</code> interface during testing.</p>

<h2 id="decorators">Decorators</h2>

<p>Now let's say that we want our application to make all HTTP calls with a certain User-Agent header. We don't want to go into our code and change every occurrence of <code>new Request</code> to also include that specific header. This is where decorators come in. We can "wrap" the <code>HttpClient</code> instance in a shell that acts as if it's the original <code>HttpClient</code>, but just takes the incoming <code>Request</code> and adds that header to it, and then passes on the call to the wrapped <code>HttpClient</code>. Like this:</p>

<pre><code class="php">&lt;?php

namespace CoffeeRun;

final class ClientWithUserAgent implements HttpClient
{
    private $wrappedClient;
    private $userAgentString;

    public function __construct(HttpClient $wrappedClient, $userAgentString = 'Coffee Bot 1.0')
    {
        $this-&gt;wrappedClient = $wrappedClient;
        $this-&gt;userAgentString = (string) $userAgentString;
    }

    public function execute(Request $request): Response
    {
        $request = $request-&gt;withHeader('User-Agent', $this-&gt;userAgentString);

        return $this-&gt;wrappedClient-&gt;execute($request);
    }
}
</code></pre>

<p>Creating an instance looks something like this:</p>

<pre><code>&lt;?php

$httpClient = new ClientWithUserAgent(
    new ClientCurl(),
    'ROBOCOP'
);
</code></pre>

<p>As this Decorator also implements the same <code>HttpClient</code> interface, the application doesn't even know this is happening, because from the outside it looks and behaves exactly the same. This change essentially now is a change in the configuration file of our Dependency Injection Container, no other files needed to be changed to make this happen.</p>

<h2 id="using-decorators-for-investigation">Using decorators for investigation</h2>

<p>Now, if we want to investigate the requests and responses that we get from a service while the application is running, e.g. when an unidentified bug is happening, we could do it with a decorator. The rest of the application won't know about it and should just keep on working as usual, while we get logs of the data that we want:</p>

<pre><code class="php">&lt;?php

namespace CoffeeRun;

final class LoggingClient implements HttpClient
{
    private $wrappedClient;
    private $logger;

    public function __construct(HttpClient $wrappedClient, LoggerInterface $logger)
    {
        $this-&gt;wrappedClient = $wrappedClient;
        $this-&gt;logger = $logger;
    }

    public function execute(Request $request): Response
    {
        $this-&gt;logger-&gt;debug('request', $request);

        $response = $this-&gt;wrappedClient-&gt;execute($request);

        $this-&gt;logger-&gt;debug('response', $response);

        return $response;
    }
}
</code></pre>

<p>The request and response are logged in our logs now, and they look good to us, but we still haven't found what we're looking for and we want to see if the requests our app is making work from the command line using <code>curl</code>. What if we made our application also log the complete curl commands? Then we could just copy paste them in our terminal to test them locally.</p>

<pre><code class="php">&lt;?php

namespace CoffeeRun;

final class CurlCommandLoggingClient implements HttpClient
{
    private $wrappedClient;
    private $logger;

    public function __construct(HttpClient $wrappedClient, LoggerInterface $logger)
    {
        $this-&gt;wrappedClient = $wrappedClient;
        $this-&gt;logger = $logger;
    }

    public function execute(Request $request): Response
    {
        $method = $request-&gt;getMethod();
        $url = $request-&gt;getUrl();
        $params = $request-&gt;getParams();
        $headers = $request-&gt;getHeaders();

        $curlString = 'curl';
        $curlString .= ' --' . strtolower($method);

        foreach ($params as $key =&gt; $value) {
            $curlString .= ' --data "' . $key . '=' . $value . '"';
        }

        foreach ($headers as $key =&gt; $value) {
            $curlString .= ' --header "' . $key . '=' . $value . '"';
        }

        $curlString .= ' "' . $url . '"';

        $this-&gt;logger-&gt;debug('curl command', $curlString);

        return $this-&gt;client-&gt;execute($request);
    }
}
</code></pre>

<p>Of course, this is an oversimplified way of building the <code>curl</code> command, but this will help you debug your HTTP calls by copy/pasting them to your terminal! Easy as that, and still no changes to the existing code. It takes one line to change it, and one line to delete and bring it back to production values.</p>

<h2 id="concerns">Concerns</h2>

<ul>
<li>Liskov Substition Principle: It's very important that our decorators still adhere to the original contract of the wrapped instance (in this case the <code>HttpClient</code> interface). If the decorator would produce another return value, or take different method parameters, it wouldn't work.</li>
<li>Applying a decorator that logs a lot of data in production might have an impact on your host. This is just an example of using your existing interfaces to create some plug &amp; play debugging solutions. If you do something like this in production, use the same caution as with other changes in production.</li>
</ul>

<p>That's it! Have fun.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Star Vars, an intergalactic story of tiny code smells]]></title>
            <link href="/blog/2017/09/01/star-vars"/>
            <updated>2017-09-01T10:00:00+00:00</updated>
            <id>/blog/2017/09/01/star-vars</id>
            <content type="html"><![CDATA[<p>In this post, we'll look at a type of variables that I call Star Vars, they're stars and shouldn't be touched. In any case. Whatsoever. Just don't start editing these in your code, or you'll eventually break stuff, with 100% guarantee.</p>

<h2 id="star-vars-i%3A-the-timestamp-menace">Star Vars I: The Timestamp Menace</h2>

<p>Timestamps are nice: asking the Unix Epoch timestamp results in a number that's the same, independent of in which timezone you are. The secret to this, is that a moment in history was labeled as Unix Epoch, and the timestamp is just the number of seconds that has passed from that moment up until now.</p>

<p>And that's where things start to get nasty: with the understanding of what the number means (the number of seconds passed since January 1st 1970), people start editing the number to get dates in the past or future. What they're almost never take in consideration is the fact that time isn't linear, dates aren't the same around the globe, there are leap seconds, leap years, etc. There are too many exceptions from the rule, to just start adding <code>60 * 60 * 24</code> seconds to a timestamp's value, to get the next day. Don't do it. Your language most probably has a <code>DateTime</code> package to do just that, with less mistakes.</p>

<h2 id="star-vars-ii%3A-attack-of-the-%60%24_post%60">Star Vars II: Attack Of The <code>$_POST</code></h2>

<p>When a HTTP request is made to your app, there are most likely <code>POST</code> or <code>GET</code> parameters being passed along. In PHP, and likely other languages, these are made available trough (global) variables, no different than other variables. Thus, they can be changed, or used in computations or output. Be very careful with that!</p>

<p>Changing a global variable means that it will be changed everywhere, so you risk breaking functionality in other places when you change e.g. the <code>$_POST</code> variable. Optimally, you could reduce the risk by using the immutable datastructures that your PSR-7 framework makes available to you.</p>

<p>Also, using user input in calculations and/or output might result in errors or major hacks of your software. Be very cautious! People might be able to steal your app's data, run arbitrary code on your server, or impersonate users.</p>

<h2 id="star-vars-iii%3A-events-of-the-sith">Star Vars III: Events Of The Sith</h2>

<p>Since forever now, people use event dispatching and event sourcing as a way to let systems know about state changes, or even build their state from scratch based on events only. These <em>events</em> are nothing more than a "record" of something that has happened (in the past complete sense). Something that has happened will never change anymore, so the variables holding events should never be changed. Events are <em>immutable</em>. If you do change them, you change history, which I assume you aren't enabled to do.</p>

<h2 id="star-vars-iv%3A-a-new-%60%24row%60">Star Vars IV: A New <code>$row</code></h2>

<p>Here's the classic "naming things" exercise. We all know it's hard, but it's also very important. Take your time, give variables an appropriate name. I'm not touching your <code>$row</code> because I don't know what it is.</p>

<h2 id="star-vars-v%3A-the-query-strikes-back">Star Vars V: The Query Strikes Back</h2>

<p>Whether you're using an ORM or not, you might write the occasional database query from time to time. I find myself still writing my own queries for the sake of simplicity, inside the database specific implementation of e.g. a repository. Sometimes, for instance when you need "filter" functionality over a huge number of entities based on their various properties, it's tempting to write a query in a very generic way so that reusable parts of the query get concatenated into one final query. I find this a very dangerous practice, all the while not providing much benefit over writing the same query a few times with minor changes. Since the repository implementation we're doing this in is the only place in our codebase that knows about the database, we shouldn't care too much about duplication here.</p>

<h2 id="star-vars-vi%3A-return-of-the-id">Star Vars VI: Return Of The ID</h2>

<p>Making assumptions about the form of variables can be quite dangerous. Let's say that you expect a string to be in place, but what you get is an empty string. Is that valid? Now, think of identifiers of different objects. Sometimes, people use incremental numeric values (more often than not generated by the database) as identifiers for their objects, e.g. the <code>Person</code> with id <code>1337</code> is a cool guy. Already I can think of multiple cases of unexpected values for numerical ids, like <code>0</code>, <code>-1</code>, <code>false</code>, <code>null</code>, <code>''</code>, <code>foo</code>... If we then make the assumption that we'll save them as an integer in the database, we'll shoot ourselves in the foot by saving an object with id <code>'arrow'</code> or <code>'knee'</code>. Or what if the id is a numerical value that is too big to fit inside an integer?</p>

<p>How about string representations, do you ask? For instance, post ids on the Facebook API have ids in the form of <code>{page id}_{post id}</code>. Now that you know this, given a post with an id, could you tell me the page id? Yes, but... what if Facebook decides to change their <em>naming scheme</em> for new posts (which they actually do from time to time)? From now on posts are called <code>pid_{random number}</code>. Now if we had logic in our software that depended on the implicit knowledge of the id was being made of two parts, it will break for those new posts.</p>

<p>The moral of the story is: ids are black boxes, they could contain anything, and we shouldn't make assumptions about them, break them up into meaningful parts, or save them as anything else than strings inside the database.</p>

<h2 id="star-vars-vii%3A-the-%60git-push---force%60-awakens">Star Vars VII: The <code>git push --force</code> Awakens</h2>

<p>Even though <code>git</code> isn't a variable in the context of this blog post, I wanted to put this one in: <code>git push --force</code> is evil. The only reason why you would want to do this, is to change <em>public history</em>, which is something that can't be done. For more about that, scroll up to the Star Vars III section, or read <a href="/blog/2017/01/24/some-tips-for-a-better-git-history/">this blog post about git</a>.</p>

<h2 id="star-vars-viii%3A-the-last-url">Star Vars VIII: The Last URL</h2>

<p>The last, but not least, "star var" is the URL. Now, we all know and understand the most basic building blocks of URLs, like the scheme, tld, and query. But actually, the standard for URLs is quite complicated, and there could be many moving parts. People don't always include the scheme (e.g. the <code>https://</code> part), or the TLD is longer than 3 characters. Therefor, parsing an URL, or changing anything meaningful of it could be very error-prone. Have a look at <a href="https://daringfireball.net/2010/07/improved_regex_for_matching_urls">this regular expression to parse an URL</a>. As you can see, it's not as simple as you think. In fact, most languages have <a href="https://secure.php.net/manual/en/function.parse-url.php">built-in functionality</a> for this, as well as <a href="http://uri.thephpleague.com/">great packages</a>. As a side-note, the same goes for e-mail addresses, telephone numbers, and many other things.</p>

<p>That's it for now! Keep in mind that a lot of these problems can be solved by either using established packages, built-in language features, or <a href="https://martinfowler.com/bliki/ValueObject.html">Value Objects</a> (or a mixture of several of those). May the force be with you!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[5 simple rules for simpler code]]></title>
            <link href="/blog/2017/08/21/simple-rules-for-simpler-code"/>
            <updated>2017-08-21T11:00:00+00:00</updated>
            <id>/blog/2017/08/21/simple-rules-for-simpler-code</id>
            <content type="html"><![CDATA[<p>We as developers care about simple code. Simple code makes it easier to read and debug code which will allow you to build new features and fix bugs faster.</p>

<p>In this blogpost I would like to explain a few simple rules to get simpler code. The code examples will be written in PHP and are therefore more suited to procedural programming languages.</p>

<h2 id="1.-avoid-else">1. Avoid else</h2>

<p>This is probably my favourite rule. Avoiding else can drastically improve the readability of your code. For example:</p>

<pre><code class="php">if ($isAllowedToReadAutomationRecipes) {
  $automationRecipes = $this-&gt;repository-&gt;getByAccountId($accountId);
} else {
  $automationRecipes = [];
}
</code></pre>

<p>You can almost always simplify this to:</p>

<pre><code class="php">$automationRecipes = [];
if ($isAllowedToReadAutomationRecipes) {
  $automationRecipes = $this-&gt;repository-&gt;getByAccountId($accountId);
}
</code></pre>

<p>Look ma, no else!</p>

<h2 id="2.-use-early-returns">2. Use early returns</h2>

<p>Early returns are a nice way to simplify code. Using early returns goes hand in hand with avoiding else. For example:</p>

<pre><code class="php">class PostController
{
    public function delete()
    {
        $post = $this-&gt;repository-&gt;getById($postId);
        if ($post) {
            if ($isConfirmed) {
                $user-&gt;deletePost($post);
                $success = $this-&gt;repository-&gt;persist($post);
                if ($success) {
                    return $this-&gt;success('The post was successfully deleted');
                } else {
                    return $this-&gt;error('Something went wrong.');
                }
            } else {
                return $this-&gt;confirm('Are you sure you want to delete this post?');
            }
        } else {
            return $this-&gt;error('The post was not found.');
        }
    }
}
</code></pre>

<p>It's really hard to see the flow of the code, don't you think? Let's refactor the example to use early returns:</p>

<pre><code class="php">class PostController
{
    public function delete()
    {
        $post = $this-&gt;repository-&gt;getById($postId);
        if ($post === null) {
            return $this-&gt;error('The post was not found.');
        }
        if ($isConfirmed === false) {
            return $this-&gt;confirm('Are you sure you want to delete this post?');
        }

        $user-&gt;deletePost($post);
        $success = $this-&gt;repository-&gt;persist($post);
        if ($success === false) {
            return $this-&gt;error('Something went wrong. Try again.');
        }

        return $this-&gt;success('The post was successfully deleted');
    }
}
</code></pre>

<p>What do you prefer? I surely prefer the latter. Early returns keep the level of indentation low and make the happy path of the code visible.</p>

<h2 id="3.-use-meaningful-variables-names">3. Use meaningful variables names</h2>

<p>If you abbreviate the names of variables you probably don't have a good IDE (autocompletion). It might make sense to use abbreviations while writing some quick code but it will eventually shoot you in the back when you need to fix a bug. You'll lose valuable time by deciphering the code.</p>

<h2 id="4.-avoid-code-comments">4. Avoid code comments</h2>

<p>Each time you're commenting code you're failing to express yourself. This rule goes hand in hand with meaningful variable names. Code comments can get outdated and nothing is as damaging as lies and misinformation. The code is the only source of truth. If you find yourself writing a code comment think of ways to make it clear in the code by extracting variables and functions with meaningful names. Sometimes a well placed comment can be helpful. They'll likely explain the why while the code explains the what/how.</p>

<h2 id="5.-follow-a-consistent-coding-standard">5. Follow a consistent coding standard</h2>

<p>Following a consistent coding standard makes sure all code is formatted in the same way. Which makes it easier to read code because you expect it to be formatted in a specific way. For PHP this is <a href="http://www.php-fig.org/psr/psr-2/">PSR-2</a>. I don't like every rule in <a href="http://www.php-fig.org/psr/psr-2/">PSR-2</a> but it doesn't matter as long as everyone writes the same code. Please don't invent your own coding standard. It's a good practice to <a href="http://cs.sensiolabs.org/">lint and fix</a> coding style automatically.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I hope these simple rules will inspire you to leave the campground cleaner than you found it. Which rules do you think are important? Leave a comment (on disqus they are allowed)! If you want to know more, <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a> is good read.</p>

<p>"Avoiding else" is a rule from <a href="https://www.cs.helsinki.fi/u/luontola/tdd-2009/ext/ObjectCalisthenics.pdf">Object Calisthenics</a>. If you want to become a better developer, read it.</p>
]]></content>
        </entry>
    </feed>