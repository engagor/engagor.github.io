<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[CX Social Dev Blog]]></title>
    <link href="/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2017-05-08T08:27:37+00:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Bugfixing with Git Bisect]]></title>
            <link href="/blog/2017/05/08/bugfixing-with-git-bisect"/>
            <updated>2017-05-08T10:00:00+00:00</updated>
            <id>/blog/2017/05/08/bugfixing-with-git-bisect</id>
            <content type="html"><![CDATA[<p>Lately, we've deployed code that broke features, that were surely working in the past. Since we're quite heavy committers, things can get lost in our <code>git log</code> quite easily. That makes it harder to go back in history and find out what exactly caused the failure to happen. We simply would have to look through too many commits. That's where <code>git bisect</code> comes in!</p>

<p>The <code>git bisect</code> command provides us with a "binary search" over the commit history: we tell it when things were good for sure, and when they were bad, and bisect will jump to the commit that's in the middle between those two commits. We then test if things work as expected. If it was good at that point we know all history before that point was good, and we move on the the other half of history and apply the same process of dividing it in two and seeing if things work as expected. We do that until we arrive at a point where we know which commit broke things. That's where we need to look. The cool thing is that we can sift through a huge amount of commits in very few steps, and locate the problem quickly. Let's see how that works in practice:</p>

<ol>
<li><p>Use <code>git log</code> to find out the commit hash for a commit where we know that things worked. Let's assume for now that the current <code>HEAD</code> we're at is at a point where things fail.</p>

<p><img src="/images/2017-05-08-bugfixing-with-git-bisect/1.png" alt="Screenshot of a git log history" /></p></li>
<li><p>Let's start the bisect session and tell git which points were good and bad:</p>

<pre><code class="sh">git bisect start
git bisect good {the commit hash where it was good}
git bisect bad
</code></pre>

<p>As you can see, I didn't specify a commit hash for the <code>git bisect bad</code> command. Bisect assumes that we mean <code>HEAD</code> if we don't specify a commit. Since the current commit is bad, and <code>HEAD</code> always points to the currently checked out commit, we can leave this blank.</p>

<p><img src="/images/2017-05-08-bugfixing-with-git-bisect/2.png" alt="Screenshot of the first steps of a git bisect session" /></p></li>
<li><p>Now git will checkout a commit in the middle between our <code>good</code> and <code>bad</code> indications. Just do what you have to do to check if things work or not, e.g. run a unit test, or do some manual checks. Then pass that info on to git with <code>git bisect good</code> if things work, and <code>git bisect bad</code> if they don't.</p>

<p><img src="/images/2017-05-08-bugfixing-with-git-bisect/3.png" alt="Screenshot of a git bisect bad" /></p></li>
<li><p>Repeat <em>step 3</em> until git knows which commit went bad. It will indicate the process at every step. When it's done, git will show you the exact commit where things went from <code>good</code> to <code>bad</code>, using <code>git show</code> behind the scenes. You then know where to look to fix your problem.</p>

<p><img src="/images/2017-05-08-bugfixing-with-git-bisect/4.png" alt="Screenshot of the result of a bisect session: 1 commit" /></p></li>
</ol>

<p>To go back to master, do a simple <code>git bisect reset</code>. Congratulations! You've used <code>git bisect</code> to locate a problem in your commit history! Now, there are some more things to know:</p>

<h3 id="when-something-goes-wrong">When something goes wrong</h3>

<p>What if you did something wrong? You typed <code>git bisect bad</code> when everything was fine and you should've typed <code>git bisect good</code>? No worries! Bisect has a secret weapon: <code>git bisect log</code>, which lets you dump the history of this bisect session to a file. You can then remove the faulty step from the file with a text editor, and replay the entire session without that bad step.</p>

<ol>
<li><p>Save your session to a file:</p>

<pre><code class="sh">git bisect log &gt; {filename}
</code></pre></li>
<li><p>Remove the faulty line from the file using your favorite text editor:</p>

<pre><code class="sh">vim {filename}
</code></pre></li>
<li><p>Reset your <code>bisect</code> session:</p>

<pre><code class="sh">git bisect reset
</code></pre></li>
<li><p>Replay the correct steps:</p>

<pre><code class="sh">git bisect replay {filename}
</code></pre></li>
<li><p>Do the rest of the bisect steps to find out where things went wrong. You can remove the replay file:</p>

<pre><code class="sh">rm {filename}
</code></pre></li>
</ol>

<h3 id="automating-the-steps-using-a-script-or-test">Automating the steps using a script or test</h3>

<p>You can automate the recursive steps of telling git that a revision is good or bad, by a simple bash script or unix command that returns a <code>0</code> status code on success, and <code>1</code> on failure. That way, if you have a testsuite, you can use that to really quickly find out where things went wrong by adding a test to it (the code is obviously not tested well or it wouldn't have happened so long ago), and using that test as the command. Let's see how that works:</p>

<pre><code class="sh">git bisect start
git bisect good {the commit hash where it was good}
git bisect bad
git bisect run {path to the script to run}
</code></pre>

<p>Don't forget to end your session with a <code>git bisect reset</code> when you found the offending commit.</p>

<h3 id="fantastic-on-fridays">Fantastic On Fridays</h3>

<p>So next time a nasty bug report comes in on a Friday -you're about to leave for a great weekend with your mates- and there were a thousand commits pushed to production that day by your team, don't dispair! Fire up <code>git bisect</code> and find where you need to be in a few minutes time, revert the commit, and enjoy your weekend!</p>

<p>Happy bughunting!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Building a sliding window rate limiter with Redis]]></title>
            <link href="/blog/2017/05/02/sliding-window-rate-limiter-redis"/>
            <updated>2017-05-02T14:00:00+00:00</updated>
            <id>/blog/2017/05/02/sliding-window-rate-limiter-redis</id>
            <content type="html"><![CDATA[<p>For our Instagram crawler we needed a system to keep track of the amount of API calls we did to prevent us from hitting the rate limits. We could of course perform our HTTP requests without checking rate limits upfront, and wait until we get a <code>429 OAuthRateLimitException</code> from Instagram, but that would exhaust our tokens and block us from talking efficiently to their API.</p>

<p><img src="/images/2017-05-02-sliding-window-rate-limiter-redis/429.jpg" alt="Too many cats" /></p>

<blockquote>
  <p>All rate limits on the Instagram Platform are controlled separately for each access token, and on a sliding 1-hour window.</p>
  
  <p><a href="https://www.instagram.com/developer/limits">Instagram API rate Limits</a></p>
</blockquote>

<p>We're allowed to do 5000 API calls per access token each hour.</p>

<p><img src="/images/2017-05-02-sliding-window-rate-limiter-redis/slidingwindow.png" alt="Sliding window ratelimiting visualisation" /></p>

<p>Every point on the axis represents an API call. The sliding window is an hour in this case. Every time we do an API call we add the timestamp (in microseconds) of the API call to a list. In pseudocode:</p>

<pre><code class="js">timestamps.push(Date.now());
</code></pre>

<p>When we're about to do an API call in our crawler we need to check if we're allowed to do one:</p>

<ol>
<li>How many calls did we do in the last hour?</li>
</ol>

<pre><code class="js">callsInTheLastHour = timestamps.filter(timestamp =&gt; timestamp &gt; now - slidingWindow);
count = callsInTheLastHour.length
</code></pre>

<ol start="2">
<li>How many can we still do?</li>
</ol>

<p>After we calculated the amount of API calls we did in the last hour we can calculate the remaining API calls:</p>

<pre><code class="js">remaining = maxCallsPerHour - count;
</code></pre>

<p>Let's say we did <code>4413</code> API calls in the last hour then we're allowed to do <code>587</code> more at this moment.</p>

<p>Great, we got our algorithm. Now we need some kind of database to store a list of timestamps grouped per access token. Maybe we could use MySQL or PostgreSQL? Yes, we could but then we would need a system that periodically removes outdated timestamps since neither MySQL or PostgreSQL allow us to set a time to life on a row. What about <a href="http://memcached.org/">Memcached</a>? Yes, that's also an option. Sadly Memcached doesn't have the concept of an array or list (we could serialize an array using our favourite programming language). We can do better. What about <a href="https://redis.io/">Redis</a>? Yes, I like where this is going. Redis is a key/value store that supports lists, sets, sorted sets and more.</p>

<p>We're ready to translate our algorithm to Redis commands. Assuming you already have Redis installed, start a server: <code>$ redis-server</code>. If you're on a mac, you can just <code>$ brew install redis</code> to get it.</p>

<p>We're going to use a <a href="https://redis.io/commands/#sorted_set">sorted set</a> to hold our timestamps because it fits our needs.</p>

<pre><code>&gt; MULTI
&gt; ZREMRANGEBYSCORE $accessToken 0 ($now - $slidingWindow)
&gt; ZRANGE $accessToken 0 -1
&gt; ZADD $accessToken $now $now
&gt; EXPIRE $accessToken $slidingWindow
&gt; EXEC
</code></pre>

<p>Let's break it down:</p>

<ul>
<li><code>MULTI</code> to mark the start of a transaction block. Subsequent commands will be queued for atomic execution using <code>EXEC</code>.</li>
<li><code>ZREMRANGEBYSCORE $accessToken 0 ($now - $slidingWindow)</code> to remove API call timestamps that were done before the start of the window.</li>
<li><code>ZRANGE $accessToken 0 -1</code> to get a list of all API call timestamps that happened during the window.</li>
<li><code>ZADD $accessToken $now $now</code> to add a log for the current API call that we're about to do.</li>
<li><code>EXPIRE $accessToken $slidingWindow</code> to reset the expiry date for this sorted set of timestamps (for the current OAuth Token).</li>
<li><code>EXEC</code> will execute all previously queued commands and restore the connection state to normal.</li>
</ul>

<p>Instead of using the actual OAuth access tokens (and duplicating them to Redis), you might want to use an identifier or hash of the token instead as <code>$accessToken</code>. It serves as the key for our Redis sorted set. Also note that, in the same transaction as reading the list of timestamps, we <em>add</em> a new timestamp to the list (the <code>ZADD</code> command). We do this because this is being used in a distributed context (we have many workers performing API calls), and we don't want to write when we already exceeded our limits.</p>

<p>In PHP this might look like this:</p>

<pre><code class="php">// composer require predis/predis
require_once __DIR__ . '/vendor/autoload.php';

$maxCallsPerHour = 5000;
$slidingWindow = 3600;

$now = microtime(true);
$accessToken = md5('access-token');

$client = new Predis\Client();
$client-&gt;multi();
$client-&gt;zrangebyscore($accessToken, 0, $now - $slidingWindow);
$client-&gt;zrange($accessToken, 0, -1);
$client-&gt;zadd($accessToken, $now, $now);
$client-&gt;expire($accessToken, $slidingWindow);
$result = $client-&gt;exec();

// The second command inside the transaction was ZRANGE,
// which returns a list of timestamps within the last hour.
$timestamps = $result[1];

$remaining = max(0, $maxCallsPerHour - count($timestamps));

if ($remaining &gt; 0) {
    echo sprintf('%s: Allowed and %d remaining', $now, $remaining) . PHP_EOL;
} else {
    echo sprintf('%s: Not allowed', $now) . PHP_EOL;
}
</code></pre>

<p>To conclude all of this, and to make this work within our codebase, we put this all nicely in a class, behind an interface <code>RateLimiter</code>:</p>

<pre><code class="php">&lt;?php

namespace CXSocial\RateLimiter;

interface RateLimiter
{
    /**
     * Request the remaining ratelimit points
     *
     * @param RateLimitedResource $rateLimitedResource
     *
     * @throws SorryRateLimitUnavailable
     *
     * @return int
     */
    public function remaining(RateLimitedResource $rateLimitedResource);
}
</code></pre>

<p>This allows us to write code that doesn't couple to implemention too much. This has been working like a charm for us! We're huge fans.</p>

<p><img src="/images/2017-05-02-sliding-window-rate-limiter-redis/fan-limit.gif" alt="HUGE FAN" /></p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Vim As A PHP IDE - Git]]></title>
            <link href="/blog/2017/04/18/vim-ide-git"/>
            <updated>2017-04-18T10:00:00+00:00</updated>
            <id>/blog/2017/04/18/vim-ide-git</id>
            <content type="html"><![CDATA[<p><strong>This blogpost is part of the "Vim As A PHP IDE" series, which starts <a href="/blog/2017/01/01/vim-ide-setting-up">here</a>.</strong></p>

<p>As developers we use Git <strong>a lot</strong>. I mean the whole time.</p>

<blockquote>
  <p>Why did I do that?</p>
</blockquote>

<p>A.k.a <code>git blame</code></p>

<blockquote>
  <p>What am I doing?</p>
</blockquote>

<p>A.k.a. <code>git status</code></p>

<blockquote>
  <p>What did I change?</p>
</blockquote>

<p>A.k.a. <code>git diff</code></p>

<blockquote>
  <p>This is why I did this!</p>
</blockquote>

<p>A.k.a. <code>git commit</code></p>

<p>I wouldn't know how to work without git anymore, and it has also found its way into my "IDE" workflow, even though I used it "purely" from the cli for a long time. Let's see how to work with git from Vim. I'm assuming you have the git binary installed on your system.</p>

<h2 id="seeing-what-changed-in-the-current-file">Seeing what changed in the current file</h2>

<p>There's this neat little plugin called <a href="https://github.com/airblade/vim-gitgutter">GitGutter</a>, which just shows you the classic <code>+</code> and <code>-</code> signs next to added and deleted code in open files. As an added bonus, it lets you jump between changed blocks of code within a file, using the <code>:GitGutterNextHunk</code> and <code>:GitGutterPrevHunk</code> commands, which you can bind to a key in your <code>.vimrc</code>, e.g.:</p>

<pre><code class="vim">" Hop from gitgutter hunk to hunk
nmap &lt;Leader&gt;v :GitGutterNextHunk&lt;CR&gt;
nmap &lt;Leader&gt;b :GitGutterPrevHunk&lt;CR&gt;
</code></pre>

<p><img src="/images/2017-04-18-vim-ide-git/git-gutter.png" alt="Git Annotations In Gutter" /></p>

<h2 id="the-real-deal">The Real Deal</h2>

<p>Using git from Vim couldn't be more intuitive (and powerful) than with <a href="http://github.com/tpope/vim-fugitive">Fugitive</a>. I do everything from Vim now.</p>

<h3 id="why-did-i-do-that%3F-%60%3Agblame%60">Why did I do that? <code>:Gblame</code></h3>

<p>Using the Fugitive <code>:Gblame</code> command, you quickly annotate the current file with <code>git blame</code> information, which lets you jump through history. From the annotation, you can just press <code>Enter</code> and see the complete commit in which that line was changed. From that commit view, you can again use <code>Enter</code> to dive in the history of that file even further, until you found what you were looking for.</p>

<p><img src="/images/2017-04-18-vim-ide-git/git-blame.png" alt="Git Blame With Fugitive" /></p>

<h3 id="what-am-i-doing%3F-%60%3Agstatus%60">What am I doing? <code>:Gstatus</code></h3>

<p>The <code>:Gstatus</code> command opens a split window in Vim, which is an interactive wrapper around the output of <code>git status</code>. From there, you can jump between files in the list using <code>&lt;C-n&gt;</code> and <code>&lt;C-p&gt;</code>, press <code>Enter</code> to open the file under cursor, and use <code>-</code> to <code>git add</code> files or <code>git reset</code> them. You can also press <code>p</code> to <code>git add --patch</code> them and see what you're doing. When you're done, you can press <code>C</code> to commit.</p>

<p><img src="/images/2017-04-18-vim-ide-git/git-status.png" alt="Git Status With Fugitive" /></p>

<h3 id="the-rest-of-git">The rest of git</h3>

<ul>
<li>Fugitive has <strong>really</strong> extensive support for resolving merge conflicts and diffing files, using Vim's built-in diff view. Here's some <a href="http://vimcasts.org/episodes/fugitive-vim-resolving-merge-conflicts-with-vimdiff/">great info about how that works</a>.</li>
<li>There's the <strong>great</strong> <code>:Gbrowse</code>, which opens the current file on GitHub (or other configurable host), and you can even use a Vim Visual mode selection and use <code>:Gbrowse</code> to directly link to those lines on GitHub.</li>
<li>There's a proxy command called <code>:Git</code> which just proxies everything to the command line git. This means you can <code>:Git pull</code> and other commands, just like you used to.</li>
</ul>

<h2 id="hotkeys">Hotkeys</h2>

<p>I created some hotkeys in <code>.vimrc</code>:</p>

<pre><code class="vim">" Git leader hotkeys
nmap &lt;Leader&gt;gs :Gstatus&lt;CR&gt;
nmap &lt;Leader&gt;gc :Gcommit&lt;CR&gt;
nmap &lt;Leader&gt;gb :Gblame&lt;CR&gt;
</code></pre>

<h2 id="wrapping-up">Wrapping up</h2>

<p>That's it really, super easy integration of git. Of course you could e.g. also integrate your current branch into your Vim statusline. Just check Fugitive's documentation! I don't feel the need for that, as I <code>:Gstatus</code> practically the whole time, and as a result, I see which branch I'm on the whole time! See you in the next episode!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Emoji as conversation enhancement]]></title>
            <link href="/blog/2017/04/06/emoji-conversations"/>
            <updated>2017-04-06T16:15:00+00:00</updated>
            <id>/blog/2017/04/06/emoji-conversations</id>
            <content type="html"><![CDATA[<p>At CX Social, we use emoji extensively. 💰💭 We believe they are an enrichment of ongoing conversations, and can be used to express things that can't be expressed in a textual representation. Let's see how and where we use them 👌</p>

<h2 id="slack">Slack</h2>

<p>Our main communication form is chat. We use Slack and we just love the integration of emoji in their application! They're everywhere! 😻</p>

<p><img src="/images/2017-04-06-emoji-conversations/1.png" alt="emoji in between text in slack" /></p>

<p>Also, the "reactions" are quite handy to not mess up conversation flow with emoji only.</p>

<p><img src="/images/2017-04-06-emoji-conversations/2.png" alt="emoji reactions in slack" /></p>

<p>In full conversation, it looks a bit like this:</p>

<p><img src="/images/2017-04-06-emoji-conversations/3.png" alt="mixture of reactions in slack" /></p>

<h2 id="github">GitHub</h2>

<p>Of course, our conversations in Issues and Pull Requests on github resemble those on Slack...</p>

<p><img src="/images/2017-04-06-emoji-conversations/4.png" alt="github reviews with emoji" /></p>

<p>And in our commits, we use the <a href="http://gitmoji.carloscuesta.me/">gitmoji</a> way of prefixing commit messages with one or more semi-standardized emoji, to make it <strong>much clearer</strong> what the commit is about.</p>

<p><img src="/images/2017-04-06-emoji-conversations/5.png" alt="gitmoji in commit messages" /></p>

<h2 id="emoji-news">Emoji-news</h2>

<p>To top it off, there's a dedicated channel on our company chat for <strong>emoji-only</strong> conversation. It's called <code>#emoji-news</code>.</p>

<p><img src="/images/2017-04-06-emoji-conversations/6.png" alt="emoji news, conversations with emoji only" /></p>

<p>The great thing about all this, is that emoji really have positive vibes about them, and they work in an inspiring, encouraging way in conversations. They make you laugh, or they express a feeling that could be very difficult to express in text only. They provide context to what was said. They can be combined to create whole stories in just a few images. They work cross-language. They can be abused. It's just fantastic 😏. We are so into it, that we added 100's of our own custom emoji to slack, which in turn add much more specific things that we could express (you can find some of them in the screenshots above). If you're looking for custom emoji, <a href="http://slackmojis.com">Slackmojis</a> is a great place to start looking.</p>

<p><img src="/images/2017-04-06-emoji-conversations/7.png" alt="a small part of our custom emoji on slack" /></p>

<p>Do you use emoji differently? Do you have tips for us? Let us know 📯</p>

<p>Have a great day! ☕️</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[How to edit a commit message]]></title>
            <link href="/blog/2017/04/03/how-to-edit-commit-description"/>
            <updated>2017-04-03T10:00:00+00:00</updated>
            <id>/blog/2017/04/03/how-to-edit-commit-description</id>
            <content type="html"><![CDATA[<p>We use GitHub for hosting the code, and issue tracker behind CX Social. As you may already know, you can close issues automatically by adding <code>Closes #issue</code> to a commit message and merging it in the master branch. This is great because I always forget to close the fixed issue (it's also great for cross-linking between issues and commits).</p>

<p>But what if you forgot to add <code>Closes #issue</code> to your commit? Let me teach you a trick to edit a commit message.</p>

<p>Let's make a new directory to test it.</p>

<pre><code class="sh">$ mkdir demo-git-edit
$ cd demo-git-edit
$ git init
Initialized empty Git repository in /Users/hansott/Code/demo-git-edit/.git/
</code></pre>

<p>Okay great. We've got our repository ready. Let's add a file.</p>

<pre><code class="sh">$ touch app.js
</code></pre>

<p>Then add the following contents:</p>

<pre><code class="js">throw new Error('This is a bug!');
</code></pre>

<pre><code class="sh">$ git add app.js
$ git commit -m "Add bug"
[master (root-commit) 308c96d] Add bug
 1 file changed, 1 insertion(+)
 create mode 100644 app.js
</code></pre>

<p>Let's fix the bug by removing it.</p>

<pre><code class="sh">$ echo &gt; app.js
$ git diff
diff --git a/app.js b/app.js
index 128b630..8b13789 100644
--- a/app.js
+++ b/app.js
@@ -1 +1 @@
-throw new Error('This is a bug!');
+
$ git add app.js
$ git commit -m "Fixed bug"
$ git log
* 83ac3a3 Fixed bug
* 308c96d Add bug
</code></pre>

<p>There you go. We forgot <code>Closes #issue</code>. What can we do about it? It's important that you don't push (otherwise you'll have to use <code>--force</code> and you should <strong>never</strong> do that).</p>

<p>If you want to edit your last commit you can use:</p>

<pre><code class="sh">$ git commit --amend -m "Fixed bug" -m "Closes #issue"
[master f27a1ca] Fixed bug
 Date: Wed Feb 1 12:31:29 2017 +0100
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>

<p>You should consider committing with <code>$ git commit --amend</code>. It opens a proper text editor (like <a href="http://vim.sourceforge.net/">vim</a>) to write a comprehensive message (instead of using <code>-m "message"</code>). Did you notice I used <code>-m</code> twice? You can read about it in <a href="/blog/2017/01/24/some-tips-for-a-better-git-history/">Some tips for a better Git history</a>.</p>

<pre><code class="sh">$ git show f27a1ca
ommit f27a1caac3ee33ac3b0ef81040cd2c2f877f13f4
Author: Hans Ott &lt;hans.ott@clarabridge.be&gt;
Date:   Wed Feb 1 12:31:29 2017 +0100

    Fixed bug

    Closes #issue

diff --git a/app.js b/app.js
index 128b630..8b13789 100644
--- a/app.js
+++ b/app.js
@@ -1 +1 @@
-throw new Error('This is a bug!');
+
</code></pre>

<p>Hooray! We did it. What if we added other commits before we realised we forgot? <a href="https://git-scm.com/book/tr/v2/Customizing-Git-Git-Configuration">I'll assume you got a decent text editor configured for git</a>.</p>

<pre><code class="sh">$ git log
* 889da98 Add leftpad
* b1b364c Add library
* 05e664c Fixed bug
* 308c96d Add bug
</code></pre>

<p>We added 2 commits after our bug fix commit. Since <code>$ git commit --amend</code> can only change the last commit, we can't use it. Luckily, we know the secret behind the curtain: it's doing a git rebase of the last commit. Let's use git rebase for great good! Again, be careful, this won't work if you already pushed your work (you can inspect with <code>$ git log --decorate</code>).</p>

<pre><code class="sh">$ git rebase -i 308c96d  # use the commit JUST before the bug fix commit
</code></pre>

<pre><code>.g/r/git-rebase-todo
pick 05e664c Fixed bug
pick b1b364c Add library
pick 889da98 Add leftpad

# Rebase 308c96d..889da98 onto 308c96d (3 commands)
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like "squash", but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to  bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
</code></pre>

<p>You'll have to replace <code>pick</code> before <code>05e664c Fixed bug</code> with <code>reword</code> and save it. Git will show the commit(s) you selected so you can edit it and save it.</p>

<pre><code>.g/COMMIT_EDITMSG
Fixed bug

Closes #issue
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# Date: Wed Feb 1 12:31:29 2017 +0100
#
# interactive rebase in progress; onto 308c96d
# Last command done (1 command done):
#    reword 05e664c Fixed bug
# Next commands to do (2 remaining commands):
#    pick b1b364c Add library
#    pick 889da98 Add leftpad
# You are currently editing a commit while rebasing branch 'master' on '308c96d'.
#
# Changes to be committed:
#       modified:   app.js
</code></pre>

<pre><code class="sh">$ git rebase -i 308c96d
[detached HEAD 4225a9a] Fixed bug
 Date: Wed Feb 1 12:31:29 2017 +0100
 1 file changed, 1 insertion(+), 1 deletion(-)
Successfully rebased and updated refs/heads/master.
</code></pre>

<pre><code class="sh">$ git show 308c96d
commit 4225a9a3eb74b42772297a2f4b67b58696e11410
Author: Hans Ott &lt;hans.ott@clarabridge.be&gt;
Date:   Wed Feb 1 12:31:29 2017 +0100

    Fixed bug

    Closes #issue

diff --git a/app.js b/app.js
index 128b630..8b13789 100644
--- a/app.js
+++ b/app.js
@@ -1 +1 @@
-throw new Error('This is a bug!');
+
</code></pre>

<p>Hooray! We did it again. Now pat yourself on the back.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Vim As A PHP IDE - Quality Control]]></title>
            <link href="/blog/2017/03/15/vim-ide-quality-control"/>
            <updated>2017-03-15T09:00:00+00:00</updated>
            <id>/blog/2017/03/15/vim-ide-quality-control</id>
            <content type="html"><![CDATA[<p><strong>This blogpost is part of the "Vim As A PHP IDE" series, which starts <a href="/blog/2017/01/01/vim-ide-setting-up">here</a>.</strong></p>

<p>So it seems that people find it really handy that their IDEs tell them when things are going wrong, and I can't really disagree with that. So let's see how we can get pretty much the same thing in Vim, for PHP.</p>

<ul>
<li>I need to be warned of syntax errors.</li>
<li>I need to be warned of unused variables, methods, fields, etc.</li>
<li>Every language has their own rules for indenting and tabs vs. spaces, and maybe even every project.</li>
<li>What about coding standards like PSR-2?</li>
</ul>

<p>Basically I do two things here:</p>

<ol>
<li>I make sure that my editor is configured correctly for the language and the project, using a simple default configuration in my <code>.vimrc</code> which I overwrite on a project basis using <a href="http://editorconfig.org/">EditorConfig</a>.</li>
<li>I use some static analysis tools for the other parts.</li>
</ol>

<h2 id="1.-basic-setup">1. Basic setup</h2>

<h3 id="filetype-plugin">Filetype plugin</h3>

<p>Depending on your taste, you might want to update your PHP filetype plugin in Vim, with a more modern version, for instance if you'd like <code>@param</code> highlighted differently in your PHPDoc blocks. You can find a more up-to-date plugin <a href="https://github.com/StanAngeloff/php.vim">here</a>.</p>

<h3 id="editor-config">Editor Config</h3>

<p>To properly configure my editor, I use the simple snippet in my <code>~/.vim/ftplugin/php.vim</code> that I also posted in the first episode of this blog series:</p>

<pre><code class="vim">" Some basic PSR code style rules
set tabstop=4           " Tab width
set softtabstop=4       " Soft tab width
set shiftwidth=4        " Shift width
set expandtab           " Use spaces instead of tabs
</code></pre>

<p>I override this with project settings, using <a href="http://editorconfig.org/">EditorConfig</a>. It's as easy as installing the <a href="https://github.com/editorconfig/editorconfig-vim">EditorConfig plugin</a> for Vim.</p>

<p>In my projects I then have a <code>.editorconfig</code> file that might look like this:</p>

<pre><code class="editorconfig">; This file is for unifying the coding style for different editors and IDEs.
; More information at http://editorconfig.org

root = true

[**.{php,js,scss,html}]
charset = utf-8
indent_size = 4
indent_style = space
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true
</code></pre>

<h2 id="2.-static-analysis">2. Static Analysis</h2>

<p>On to more interesting stuff, for the rest of our list: syntax errors, coding guideline violations, unused variables, and the like. The cool part of this, is that many of these things are covered by great PHP tools:</p>

<ul>
<li>syntax errors: <code>php -l</code></li>
<li>coding guideline violations: <a href="https://pear.php.net/package/PHP_CodeSniffer/">PHP Code Sniffer</a></li>
<li>unused variables and other possible issues with code: <a href="https://phpmd.org/">PHP Mess Detector</a></li>
</ul>

<p>Even greater is that there's a great Vim plugin that combines all of these quality control tools into one great automated package: <a href="https://github.com/vim-syntastic/syntastic">Syntastic</a>, and it's fantastically easy to install. Use your Vim package manager, and put some lines into your <code>.vimrc</code> to configure it:</p>

<pre><code class="vim">" Syntastic configuration
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
</code></pre>

<p>Now to configure the PHP specific tools, that I mentioned above, I do it like this:</p>

<pre><code class="vim">" Syntastic configuration for PHP
let g:syntastic_php_checkers = ['php', 'phpcs', 'phpmd']
let g:syntastic_php_phpcs_exec = './bin/phpcs'
let g:syntastic_php_phpcs_args = '--standard=psr2'
let g:syntastic_php_phpmd_exec = './bin/phpmd'
let g:syntastic_php_phpmd_post_args = 'cleancode,codesize,controversial,design,unusedcode'
</code></pre>

<p>This works because the <code>phpcs</code> and <code>phpmd</code> binaries live in a <code>bin/</code> directory inside my project's directory (I installed them using composer). If you have global installs of these tools, you can just leave out these config lines, Syntastic knows where to find them. As we now have the <code>php -l</code> linter as a Syntastic checker, we can remove the <code>autocmd</code> from our <code>.vimrc</code>.</p>

<p>Some screenshots for the visually minded people:</p>

<p><img src="/images/2017-03-15-vim-ide-quality-control/syntax-error.png" alt="Syntax error detection with php -l" /></p>

<p><img src="/images/2017-03-15-vim-ide-quality-control/psr-violation.png" alt="PSR-2 violation" /></p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>Now I get live feedback about the quality of my code! Great! On to the next episode.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Bug Fixing: Creating Synergy Between Dev and Support]]></title>
            <link href="/blog/2017/03/01/batman-chatman"/>
            <updated>2017-03-01T09:00:00+00:00</updated>
            <id>/blog/2017/03/01/batman-chatman</id>
            <content type="html"><![CDATA[<p>This blog post is about bugs. About bug-tracking software. About prioritising what issues to fix first. About client-developer communication. About Service Level Agreements. And about hotfixes.</p>

<p><center><img src="/images/2017-03-01-batman-chatman/oh-f.gif" alt="Oh, f*ck" /></center></p>

<p>If that didn't scare you away, well hello there!</p>

<h2 id="first-line-support">First Line Support</h2>

<p>CX Social is software that allows companies to respond to their incoming social data (Twitter mentions, Facebook wall posts, etc.) as fast and as efficiently as possible. The customer care agents of companies like Telenet, De Lijn, NMBS (in Belgium), and Lufthansa, Turkish Airlines, T-Mobile (worldwide) use CX Social day-in day-out. They've set-up highly customized workflows within our tool, including automated actions, advanced filtering and real-time communication.<br />
This makes CX Social a business-critical tool for our clients to serve their customers. To help with set-up, or if clients have discovered a bug in our system, there is direct in-app access to a live chat that puts them in contact with one of our support agents.<br />
These support agents handle several chats and incoming emails per hour. We use Olark for in-app live chat, and use Salesforce Desk as the tool to handle incoming emails.</p>

<p><center><img src="/images/2017-03-01-batman-chatman/olark-chat.png" alt="CX Social in-app Live Chat via Olark" /></center></p>

<h2 id="an-empowered-support-agent-means-less-bugs">An Empowered Support Agent Means Less Bugs</h2>

<p>The support agents are the people in our company that know our tool best. In several cases even better than us developers who wrote the code for it. We involve our support agents in testing new features we build. By making support part of the Q&amp;A-process, we assure they have used new features before clients put their hands on it, but also that the product team keeps solving <em>real</em> problems that our clients are having every day.<br />
Apart from that, we actively maintain FAQ documents that help support agents identify problems, and collect the correct information to reproduce issues. We - try to - regularly organise trainings that go deep into certain aspects of our application. The customer support agents for CX Social know the basics of html, can interpret some - if not most - of our monitoring dashboards and know about <code>oAuth</code> or <code>API's</code> and find their way around the Chrome Developer Tools.<br />
All with one goal: to be able to solve our clients' problems as fast as possible. (Read: With as little help from a developer as possible 😏 )</p>

<h2 id="a-direct-line-to-development">A Direct Line To Development</h2>

<p>For those cases where the help of a developer is wanted, our support team has a direct line open to development, and that's the internal Slack channel <code>#supdev</code> that all support agents have joined. The main goal of this channel is to discuss whether a certain <em>symptom</em> is in fact an issue. We've seen it work best if all these discussions happen through a single and public channel so that multiple people can jump in to help. This encourages learning from each other's questions and answers, and also helps to hand-over problems to teams in other timezones.
On the other hand, on active days, the constant flow of messages in the <code>#supdev</code> channel often get in the way of focus. That's why the people in our development team are taking turns in answering support questions in this channel, and by doing that allowing others to preserve their focus. The whole development team (all full stack developers) takes part in this schedule we nicknamed the 'chatman', in periods of one week.</p>

<p>The result of this direct line is;</p>

<ol>
<li>Less bugs:

<ul>
<li>Because some configuration errors might be spotted earlier;</li>
<li>Because multiple reports by clients get bundled into a single bug report;</li>
</ul></li>
<li>Better bug reports:

<ul>
<li>More detailed steps to reproduce;</li>
</ul></li>
</ol>

<h2 id="github-as-bug-repository">GitHub as Bug Repository</h2>

<p>We use GitHub Issues as our main bug tracker. Not that it matters that much, but here's some of the reasons we appreciate GitHub:</p>

<ul>
<li>Integration with the git repository;

<ul>
<li>Closing issues from your commit message via <code>closes #issueno</code>;</li>
<li>The automatic referencing between issues, pull requests and commits;</li>
</ul></li>
<li>It's simple and easy to use interface; and at the same time flexible enough due to its labeling system.</li>
<li>Its simple and extensive REST API.</li>
</ul>

<p>We have set-up an <a href="https://help.github.com/articles/creating-an-issue-template-for-your-repository/">issue template</a> to guide our support agents to provide as much of the relevant context as possible. This issue template makes sure we always know the User ID and Account ID of the person having/reporting the problem.</p>

<p>We have several types of issues; "critical", "minor" and "major", which we indicate with <a href="https://help.github.com/articles/creating-and-editing-labels-for-issues-and-pull-requests/">issue labels</a>. Most issues are classified as "minor", and the "major"/"critical" labels are reserved for those "drop everything and fix this"-type of problems.</p>

<p>Whenever a Desk case (= client report) results in a GitHub issue (= actual bugreport), we make sure to save the connection between the Desk case and GitHub issue in our own database. <em>(The why is explained later.)</em></p>

<p>In a typical week at CX Social around 10 bugs are reported, and while most of them take about 2 to 3 hours to fix, some take days.</p>

<h2 id="batman-will-fix-it">Batman Will Fix It</h2>

<p>Similar to how we have a dedicated person answering questions from our support team, the person(s) responsible for fixing bugs is also a rotated role. Each week different people are assigned the Batman role, and spend their week digging into the reported and confirmed issues, trying to find a solution for them.</p>

<p>This separation of bug fixing work from standard product development <em>(i.e. new features, or reworked features)</em> has the following advantages for us:</p>

<ul>
<li><p>Everyone in the team will at some point be involved in fixing bugs, including bugs in parts of the code he/she doesn't know yet. Of course, everyone's free to go ask other people's advice, but it's definitely an efficient way of preventing knowledge silos. This contributes to everyone's knowledge of the code base, and also to how much care is given to writing clean &amp; well documented code.</p></li>
<li><p>In weeks a developer isn't assigned the Batman role, he/she can fully focus on the product development project; making it easier to stay focused and work towards target dates. Before we used a system like this, it was often much harder to make progress on product development, because there's always a certain bug that got more priority.</p></li>
<li><p>By separating these duties it also becomes more measurable how much effort is spent - team-wide - on each type of job, and how we should distribute our resources.</p></li>
</ul>

<p><center><img src="/images/2017-03-01-batman-chatman/scars.jpg" alt="Do you want to know how I got these scars?" /></center></p>

<p>At the same time, a system like this creates a few problems as well:</p>

<ul>
<li><p>Probably the person trying to find the cause of a bug is not the person who originally wrote the code, and thus it might take more time than somebody who knows the ins and outs of what he/she wrote.</p></li>
<li><p>Bugs that aren't fixed by the end of the week, will of course not go away by itself, and a handover to the next batman is needed.</p></li>
</ul>

<p>The solution for this is simple: allow to deviate from the guidelines. In emergency situations, more people are working on bugs than just the Batman. And if you are close to a fix on Friday evening and fixing it will only take another half a day; of course that's what we do. And have regular in-person <code>#supdev</code>-meetings with the support team, and this and next week's Batman and Chatman.<br />
The agenda for these meetings is:</p>

<ul>
<li>What are the most important issues still needing a fix, from a support point of view?</li>
<li>What are blocking problems, from a dev point of view?</li>
<li>Passing on information to the next batman, both from support and from batman.</li>
</ul>

<p>We use this system in a tech team of 11 people, of which 7 people are involved in this Batman/Chatman schedule. The rest of the team is either designer, data scientist or ops people. While it works for us now, we realise it might become hard if the team grows.</p>

<p>On top of the GitHub API we built several dashboards that plot the trend in amount of open bugs and that show our average resolution time. These are the prime indicators we take into account when planning extra resources for this role. Our Slack bot will also notify us when issues stay open for too long, or are unassigned, or miss labels, etc.</p>

<p><center><img src="/images/2017-03-01-batman-chatman/issue-stats.png" alt="Amount of open issues over time" /></center></p>

<p>When an issue is closed but without a resolution (it's a duplicate, we were unable to reproduce it, it's a limitation of the external services we use, etc.) we indicate this with a resolution label. And similarly we tag all bugs with a label indicating which CX Social feature group it's related to. These two types of labels help us assess the quality of both our bug reports as identify problem areas with the application.</p>

<h2 id="prioritising-issues">Prioritising Issues</h2>

<p>The nature of a bug typically entails its priority; if something is a problem with a core feature of CX Social, for multiple accounts at once, it's labeled as "major", and thus has higher priority over bugs classified as "minor". Luckily, the amount of "major" bugs is limited. So, most of the time we spent fixing "minor" bugs. Typically we have between 10 and 30 of these bugs open, and from this to-do list for the Batman it's important we focus on those issues that have the most impact, for whatever reason. It's our support team that decides which of these to work on, since they know a bug's impact on customers best.</p>

<p><center><img src="/images/2017-03-01-batman-chatman/github-screenshot.png" alt="Some open issues" /></center></p>

<h2 id="what-didn%27t-work">What Didn't Work</h2>

<p>We didn't always work this way. Over the course of the last 5 years, we've had a whole bunch of different approaches.</p>

<p>In our first iterations Batman also did the duties of who we now refer to as Chatman. But complex bugs often require a lot of focus (and we found out: more so than for standard product development work), so this combined role, resulted in a lower bug closing efficiency. And that's of course the main target for a system like this.</p>

<p>Not having a Chatman at all, is even worse. The fact that a developer can add his/her perspective to a bug report, greatly enriches the quality of a bug report. The fact that this communication with the Chatman happens over chat, avoids a slow ping-pong of "needs more information" comments on GitHub issues.</p>

<p>While it's sometimes tempting to skip a weekly <code>#supdev</code>-meetings, we've found that not having a regular in-person meeting between development and support creates an invisible "hostility" where it feels like one party is fighting against the other: fixing bugs versus reporting bugs. While what really happens is two teams working together to fix customer issues. Talking in person can cause breakthroughs because ideas get validated or ping-ponged.</p>

<h2 id="deploying-fixes-%26-reaching-out-to-the-customer">Deploying Fixes &amp; Reaching Out to the Customer</h2>

<p>When a developer has fixed a bug, it's pushed to a separate branch which is then opened up for peer review via <a href="https://help.github.com/articles/about-pull-requests/">GitHub's Pull Requests</a> and the Support Agents involved in the bug report are notified. At this moment it's also possible to fire up a staging environment with the bug fix to verify by support.</p>

<p>Approved bug fixes are typically pushed out to production the same day. And by requiring issues to be closed via GitHub's <code>closes #issueno</code> commits, our continuous integration agent Jenkins also knows what fixes he is deploying to production. We have configured Jenkins so that it leaves a comment on the actual GitHub issue with the build number and exact time of when a fix for that issue went live. Jenkins will also make sure to post any bug fixes that are deployed to a few of the relevant Slack channels.</p>

<p><center><img src="/images/2017-03-01-batman-chatman/fixed-comment.png" alt="It's fixed" /></center></p>

<p>This Jenkins-comment on the GitHub issue will also trigger the reopening of any Desk cases associated with the GitHub issue, so that our support team immediately has the relevant cases reopened. By closing the loop back to the customer we make sure that customer immediately knows about a fix, and that we have confirmation of the fix as soon as possible.</p>

<p>What strategies have worked for you to speed up the bug fixing process and ensure positive communication between those encountering the bugs, reporting the bugs and fixing the bugs?</p>

<p><center><img src="/images/2017-03-01-batman-chatman/fixed-slack.png" alt="It's fixed" /></center></p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Vim As A PHP IDE - Exploring Code]]></title>
            <link href="/blog/2017/02/15/vim-ide-exploring-code"/>
            <updated>2017-02-15T09:30:00+00:00</updated>
            <id>/blog/2017/02/15/vim-ide-exploring-code</id>
            <content type="html"><![CDATA[<p><strong>This blogpost is part of the "Vim As A PHP IDE" series, which starts <a href="/blog/2017/01/01/vim-ide-setting-up">here</a>.</strong></p>

<p>As it turns out, finding things in a huge project is one of the main reasons people use an IDE. The most frequently used functionality seems to be</p>

<ul>
<li>searching for a file by its name;</li>
<li>searching within the current file;</li>
<li>searching for something arbitrary in the current project;</li>
<li>searching for methods or classes;</li>
<li>"jumping" to implementations of interfaces, child classes, definitions of methods;</li>
<li>finding usages of a method;</li>
</ul>

<h2 id="finding-files-by-their-names">Finding files by their names</h2>

<p>Finding files is something I'm very bad at. I mostly remember only part of the name, or nothing at all. That's why I want to search for files in a "fuzzy" way, if at all. For fuzzy file search, a feature found in most text editors and IDEs these days, I use <a href="https://github.com/kien/ctrlp.vim">CtrlP</a>, which does that just fine. It also has some nice extra commands that let you fuzzily find files in your open buffers, tags (more on that later), and bookmarks.</p>

<p>Some people like to use <a href="https://github.com/scrooloose/nerdtree">NerdTree</a> to have a nice directory listing to the left of the screen, like in Sublime Text or similar editors. You can use it, and I sometimes do for its <code>:NERDTreeFind</code> command, but for most of your needs, the default file browser in Vim is great. You can open it like you open any file, just open a directory instead e.g. <code>:e src/</code>.</p>

<h2 id="searching-within-the-current-file">Searching within the current file</h2>

<p>To find something in the current file, Vim provides a huge number of options. There's the default forward search command, <code>/</code>, which can be pimped a bit to behave in a more "natural" way. In <code>.vimrc</code>:</p>

<pre><code class="vim">set incsearch           " search as characters are entered
set hlsearch            " highlight matches
</code></pre>

<p>And you can search backwards in exactly the same way by using <code>?</code>. Jump to next and previous hits with <code>n</code> and <code>N</code>. And of course you can use regex.</p>

<p>Then there are some more "special" ways of searching in the current file:</p>

<ul>
<li>Hop to the next occurence of the word under cursor <code>*</code></li>
<li>Hop to the previous occurence of the word under cursor <code>#</code></li>
<li>Hop to the next method <code>]]</code></li>
<li>Hop to the previous method <code>[[</code></li>
<li>Hop to the definition of a variable under cursor <code>gd</code> (goto definition)</li>
</ul>

<h2 id="searching-for-arbitrary-text-in-the-current-project">Searching for arbitrary text in the current project</h2>

<p>I use <code>ag</code> as my main code search engine. It's a great command line tool to search codebases really fast. I use it on the command line, as well as in Vim, to replace <code>:vimgrep</code> with something faster. It's also the basis for some more interesting stuff, which I'll talk about later.</p>

<p>You'll need to have the <code>ag</code> binary for your operating system installed, using e.g. <code>brew install ag</code>. Check if it works by searching your codebase for a class, e.g. <code>ag HttpKernelInterface</code>.</p>

<p>Install the <code>Ack.vim</code> plugin, that you can find <a href="https://github.com/mileszs/ack.vim">here</a>. Then set the default search engine for the plugin to <code>ag</code> in your <code>.vimrc</code>:</p>

<pre><code class="vim">" Ack -&gt; Ag
if executable('ag')
    let g:ackprg = 'ag --vimgrep'
endif
</code></pre>

<p>Open Vim in your codebase's working directory and try it there, e.g. <code>:Ack HttpKernelInterface</code>. This should jump straight to the first match found.</p>

<p>The problem with this is that you don't have a visual representation of what else was found. Luckily, and much like <code>:vimgrep</code>, <code>:Ack</code> fills the quickfix list with matches, so you can use <code>:cwindow</code> to show matches (and see also <code>:cnext</code>, <code>:cprev</code>, <code>:cclose</code>). If you want your quicklist to open automatically if anything was found you can add this to your <code>.vimrc</code>:</p>

<pre><code class="vim">" Automatically open &amp; close quickfix window
autocmd QuickFixCmdPost [^l]* nested cwindow
</code></pre>

<h2 id="searching-for-methods-or-classes">Searching for methods or classes</h2>

<p>Now this is where it gets interesting, and where people somewhat underestimate Vim. Using an external application to generate an index of your project's "tags" (classes, interfaces, methods, variables, etc), which Vim can interpret, it provides jumping to all these things and back! This is great. How to set it up?</p>

<p>You'll need to have the <code>ctags</code> binary for your operating system installed, using e.g. <code>brew install ctags</code>. Check if it works by issueing this command <code>ctags --version</code>. I created a config file for it in my <code>$HOME</code> directory, called <code>.ctags</code> with this in it:</p>

<pre><code class="ctags">--recurse=yes
--tag-relative=yes
--exclude=.git
--exclude=composer.phar
--exclude=*.js
--exclude=*.vim
--langmap=php:.engine.inc.module.theme.install.php
--PHP-kinds=+cfi-vj
</code></pre>

<p>The line with <code>--PHP-kinds</code> tells <code>ctags</code> to index classes, functions, interfaces, but not variables or javascript functions. You can tune this to your likings.</p>

<p>If you now use <code>ctags</code> from the command line to generate the tags file for your project, using <code>ctags -R .</code>, a file that Vim can interpret, called <code>tags</code> will be created.</p>

<ul>
<li>You can now open Vim on a tag like so <code>vim -t HttpKernelInterface</code></li>
<li>Or search for that tag from within Vim <code>:tag HttpKernelInterface</code></li>
<li>Or jump to the tag under the cursor: <code>&lt;C-]&gt;</code> or <code>&lt;C-$&gt;</code> depending on keyboard layout</li>
<li>if you jumped to some tags and you want to jump back, use <code>&lt;C-t&gt;</code></li>
</ul>

<p>Of course there are <a href="https://github.com/ludovicchabant/vim-gutentags">plugins</a> to manage your <code>tags</code> files for you.</p>

<h2 id="finding-implementations-of-interfaces%2C-child-classes">Finding implementations of interfaces, child classes</h2>

<p>So this is where the aforementioned <code>Ack</code> magic comes in handy, as it's not default Vim functionality, and I didn't find a plugin to do these things either. I basically just created some functions that find PHP implementations of an interface, and PHP subclassses of a class. I just put them in my <code>.vimrc</code>, but I'm planning on creating a very simple plugin for them.</p>

<pre><code class="vim">" PHP Find Implementations
function! PhpImplementations(word)
    exe 'Ack "implements.*' . a:word . ' *($|{)"'
endfunction

" PHP Find Subclasses
function! PhpSubclasses(word)
    exe 'Ack "extends.*' . a:word . ' *($|{)"'
endfunction

noremap &lt;Leader&gt;fi :call PhpImplementations('&lt;cword&gt;')&lt;CR&gt;
noremap &lt;Leader&gt;fe :call PhpSubclasses('&lt;cword&gt;')&lt;CR&gt;
</code></pre>

<p>As you can see, I added mappings to execute them for the word under cursor (<code>&lt;cword&gt;</code>). These key mappings should probably be done inside the PHP <code>augroup</code> we created in the previous post.</p>

<h2 id="finding-usages-of-a-method">Finding usages of a method</h2>

<p>Pretty much in the same spirit of the Vim functions I wrote to find implementations of an interface, I also wrote such a function to find usages of a method, which I also just added to my <code>.vimrc</code>:</p>

<pre><code class="vim">" PHP Find Usage
function! PhpUsage(word)
    exe 'Ack "::' . a:word . '\(|&gt;' . a:word . '\("'
endfunction

noremap &lt;Leader&gt;fu :call PhpUsage('&lt;cword&gt;')&lt;CR&gt;
</code></pre>

<h2 id="wrapping-up">Wrapping up</h2>

<p>So that is basically how I move around in our codebase, from within Vim. It's not all perfect, but it works perfectly fine for me and I find what I need, when I need it. Up to the next episode!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Some tips for a better Git history]]></title>
            <link href="/blog/2017/01/24/some-tips-for-a-better-git-history"/>
            <updated>2017-01-24T15:00:00+00:00</updated>
            <id>/blog/2017/01/24/some-tips-for-a-better-git-history</id>
            <content type="html"><![CDATA[<p>We're all heavy Git users in the CX Social development team. Honestly, we couldn't survive without it, as some of us are located across the planet, and we also use GitHub as our primary source of information, even when talking to other teams like the "Customer Support" team. Here's some small tips we learned along the way, when it comes to keeping your Git history clean.</p>

<h2 id="%60git-log%60-like-a-boss"><code>git log</code> like a boss</h2>

<p>I personally like to see everything there is to see about my git history. That's why I have an alias for <code>git log</code> that upgrades it with two default flags:</p>

<pre><code class="sh">git log --decorate --name-status
</code></pre>

<p>The <code>--decorate</code> flag shows ref names next to commits, meaning that you can see where <code>HEAD</code> points, and where your current (and remote) branches are pointing.</p>

<p>The <code>--name-status</code> flag activates the functionality to display which files were changed in that commit, below your commit message. This is great to see what changed in a commit, at first glance.</p>

<h2 id="writing-proper-commit-messages">Writing proper commit messages</h2>

<p>Another great tip, and maybe the best thing you'll take away from this blog post, actually comes from <a href="http://chris.beams.io/posts/git-commit/">another blogpost</a> which talks about writing great <code>git commit</code> messages. If you haven't read that post, go read it now, it's awesome. The main things I took away from it are these:</p>

<ul>
<li>use a proper text editor (like Vim) for writing your commit messages</li>
<li>write a commit subject as the first line, which complete this sentence:
<code>if applied, this commit will...</code></li>
<li>keep a blank line between the subject and what follows</li>
<li><strong>always</strong> write a commit body with <strong>what</strong> changed, and <strong>why</strong> you changed it.</li>
</ul>

<p>If you're too stubborn to write your commit messages using a decent text editor, here's a trick for you: you can use the <code>-m</code> flag on your command line more than once, to create paragraphs, e.g.:</p>

<pre><code class="sh">git commit \
-m "Add a second Hyperdrive as a backup" \
-m "When being followed by an imperial fighter, we want to be able to jump to hyperspace even though our first drive fails." \
-m "We're afraid this might cause some more radiation than expected."
</code></pre>

<p>But still, really consider using a text editor.</p>

<h2 id="distributed-versioning">Distributed versioning</h2>

<p>Git is a distributed versioning system, which means that it's designed to work offline, without a connection to the remote. We might as well exploit that to have great git history.</p>

<ul>
<li><code>git checkout</code> your own feature branch to work on something</li>
<li>don't <code>push</code> or <code>pull</code> while working on your feature. This gives you the advantage that you can <code>amend</code> your commit messages if you made a mistake, or that you can even <code>rebase</code> or <code>squash</code> your commits for clarity.</li>
<li>when you're done, push your branch. If you're working alone on your feature branch, this will work fine and you're done. If there are other people working on the same branch, don't panic and proceed to the next step</li>
<li><code>git pull --rebase origin {branch-name}</code> and then push</li>
</ul>

<p>As I mentioned before, <strong>not</strong> pushing or pulling, and still being able to work is a great feature of git. It means that you can work offline and do everything as if you were the only developer working on a project. You can undo mistakes you made in git, say, you forgot to include a file in a commit. Just <code>git commit --amend</code> it to your liking. Just don't go around and change parts of history that were already pushed.</p>

<p>Now the <code>--rebase</code> part in the <code>git pull</code> step is where it gets interesting. What this does, is undo everything you did since the last time you pulled the branch. Then it pulls from the remote, so that it's a fast-forward without conflicts with 100% certainty. And then it will apply your commits to that. This means that if you changed something, and someone else changed the same thing, you will have a rebase conflict. Which is great! You can now just fix your own conflict, and the history will still be linear! This also means that you will have to fix your own conflicts from now, instead of fixing other people's conflicts. Go on and push your branch when your done.</p>

<h2 id="merging-master-in-your-feature-branch">Merging master in your feature branch</h2>

<p>In analogy with what I said before, you can look at your feature branch as an "isolated" place where you can work on your feature in separation of everything that happens in other branches. Just do what you wanted to do, and never merge any branch into it, or at least minimize the amount of times you merge in case you really really have to.</p>

<p>The advantage this gives you, is great linear history in your feature branch, which <strong>only</strong> applies to that feature, which makes it easy to review or merge into other branches. This is even more true if you use the <code>git pull --rebase</code> feature from the previous tip.</p>

<p>Now, when your feature is ready and there are merge conflicts between your feature branch, and the branch you want to merge it into, e.g. <code>master</code>, you can solve that easily. Merge master in your branch once, and fix your own conflicts. Then merge your branch into master. There are some rebase tricks you can do here to keep linear history too, but I prefer to still merge branches when a feature is done.</p>

<h2 id="further-reading">Further Reading</h2>

<ul>
<li><a href="http://chris.beams.io/posts/git-commit/">How to Write a Git Commit Message</a></li>
<li><a href="https://git-scm.com/book/en/v2/Distributed-Git-Distributed-Workflows">GitBook chapter on Distributed Workflows</a></li>
<li><a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a></li>
</ul>

<p>That's it! Enjoy your clean git logs!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Distributed Processing via RabbitMQ]]></title>
            <link href="/blog/2017/01/07/distributed-processing-via-rabbit-mq"/>
            <updated>2017-01-07T08:00:00+00:00</updated>
            <id>/blog/2017/01/07/distributed-processing-via-rabbit-mq</id>
            <content type="html"><![CDATA[<p>Looking at <a href="https://stackshare.io/clarabridge-cx-social/web-application-stack">the tech stack of our CX Social product</a>, there's tens of components involved, and this post will go into detail about one of the most central components of our system: our RabbitMQ service.</p>

<p>RabbitMQ, or at least the concept of "Message Brokers" it implements, is central to the way we capture and digest the hundreds of social media messages we track each second, but also in how we throw around workload and tasks. Actually, it's so central we often take it for granted. So, let's take a step back and see why we use it ...</p>

<h2 id="what-is-a-queueing-system%3F">What is a Queueing System?</h2>

<p>Almost too simple to explain, a queueing system is a service where you can pile up a bunch of things to do (tasks) or messages to process (social media tweets etc. in our case). Different processes put messages on the queue (publish) while multiple other processes (consumers), possibly on other servers, read from these queues to e.g. execute a certain process.</p>

<p><center><img src="/images/2017-01-07-distributed-processing-via-rabbit-mq/queue.png" alt="What Is A Queue?" /></center></p>

<p>At Clarabridge CX Social, we use <a href="https://www.rabbitmq.com/">RabbitMQ</a>, but there's also <a href="https://kafka.apache.org/">Apache Kafka</a> or <a href="https://aws.amazon.com/sqs/">Amazon SQS</a> as often used alternatives.</p>

<p>Below is a screenshot of our RabbitMQ dashboard, showing a.o. about 3000 messages per second being processed.</p>

<p><img src="/images/2017-01-07-distributed-processing-via-rabbit-mq/rabbitmq-dashboard.png" alt="RabbitMQ Dashboard" /></p>

<h2 id="so%2C-what%27s-cool-about-queues%3F">So, What's Cool About Queues?</h2>

<h3 id="1.-do-stuff-async-and-handle-peaks">1. Do Stuff Async and Handle Peaks</h3>

<p>If at any point in our code we can procrastinate, we try to do so. If it's not super important to execute a certain function immediately, we push a message onto one of our RabbitMQ queues containing enough information to execute the function later, potentially by someone else. Easy. And lazy.</p>

<p>An example where we do this, is in the processing of webhooks for Facebook. For every like or comment that happens on one of the Facebook Pages that our CX Social clients own, Facebook sends us a real-time update containing who commented/liked which post. This information needs to be added to our clients' inboxes as soon as possible, but it's not vital that that's done in the same webhook-request that Facebook sends us. So, this page just pushes whatever information it gets from Facebook onto a queue. And an army of consumers for this queue turns these messages in e.g. comment objects to add to our data cluster.<br />
Whenever a Facebook post we monitor turns out to be hugely popular, and hundreds of post interactions per second is no exception, this queue serves both as a buffer (so we can handle these peak moments) and as a distributor (so multiple processes can massage and index the data).</p>

<p>Other common use cases include emailing or notifying several people. Say you have an online shop, and you want to notify a whole bunch of subscribers as soon as you add a new item to the inventory. Instead of sending these notifications in the same web request that the admin adds a product in, you push the notification-job on a queue, and let a different process send the actual emails or push notifications. Your initial request ("Add product x") stays fast, while all necessary emails are sent in the background.</p>

<h3 id="2.-split-up-complex-problems">2. Split up Complex Problems</h3>

<p>Queues are also particularly handy to split up heavy tasks into smaller, more manageable chunks of work. By using queues as the glue between these steps, you create more visibility into this chain of events.</p>

<p>One such chain that is vital to CX Social is the processing of a new incoming message (a tweet, an Instagram photo, etc.). Whenever a new messages is capture by our data crawling systems, there's several steps we need to do to get it to our clients, including:</p>

<ol>
<li>Checking which of our clients are interested in the message by matching it to the set-up of their accounts.<br />
(E.g. does it contain any of the keywords they're monitoring? Is it from a social profile they own?)</li>
<li>Resolving any of the urls in the post, as to get more details about the linked sites.</li>
<li>Computing the language the post's text is in.</li>
<li>Making an estimated guess of what the sentiment of the post could be.</li>
<li>Predict any labels that the client uses often for this particular post.</li>
<li>Indexing it to our main data cluster (ElasticSearch).</li>
<li>Predicting a possible reply for the post, if actionable.</li>
<li>Sending a notification to logged in users to their interfaces update with the new data.</li>
</ol>

<p>Each step of this process involves different services, of which some might be external, or slow, or down. By splitting this big chunk of work into smaller steps that are executed in sequence (each step generates an event that the next step listens to), we have better control over the execution of these steps. In addition, each step is simpler to monitor and thus debug (both in resource usage as speed).</p>

<h3 id="3.-give-certain-jobs-priorities">3. Give Certain Jobs Priorities</h3>

<p>By using different queues for different types of tasks, and by playing around with the amount of consumer-processes you have running for a certain queue, you have control over the priority of the tasks you push to this service, and different queues and types of tasks don't affect each other.</p>

<h3 id="4.-cross-service-communication">4. Cross-Service Communication</h3>

<p>We also use RabbitMQ in case different services need to talk to each other. At Clarabridge CX Social we have a service for real-time communication to a user's browser using websockets (via node.js/Socket.io). Every other service in our cluster can just send their messages there via RabbitMQ.
If a certain php process needs to send a real-time notification to a certain logged in user, the php process publishes an event to a RabbitMQ queue. A node.js server will then consume the event, and passes it on the client via socket.io.<br />
Using RabbitMQ as the intermediate we allow services written in a multitude of different languages to talk to each other.</p>

<h3 id="5.-monitoring-made-easy">5. Monitoring Made Easy</h3>

<p>A benefit of architecting your application this way, is that your Message Broker becomes an important and easy service to monitor, giving early indications when problems arise. As soon as a certain queue is growing beyond its expected volume, it's often an indication of a process that is slower than expected, or fully down.</p>

<p>If you monitor ...</p>

<ul>
<li>the amount of messages on a queue at any time;</li>
<li>the age of the oldest messages on a queue;</li>
<li>the rate of publishing to a queue;</li>
<li>the rate of consuming from a queue;</li>
</ul>

<p>... you have a very good indication of the health and performance of your application.</p>

<p><img src="/images/2017-01-07-distributed-processing-via-rabbit-mq/serverdensity-dashboard.png" alt="ServerDensity Dashboard" /></p>
]]></content>
        </entry>
    </feed>